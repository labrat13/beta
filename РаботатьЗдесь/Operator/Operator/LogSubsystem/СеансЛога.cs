using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.IO;
using Operator.Utility;
using System.Globalization;

namespace Operator.LogSubsystem
{
    
    /// <summary>
    /// Обслуживает папку сеанса лога, но не работу лога
    /// </summary>
    public class СеансЛога
    {

#region Поля сеанса лога
        /// <summary>
        /// Обратная ссылка на объект менеджера лога
        /// </summary>
        private LogManager m_manager;
        /// <summary>
        /// Счетчик номера файла лога в текущем сеансе Лога и Движка.
        /// </summary>
        private Int32 m_СчетчикНомерФайлаЛога;
        /// <summary>
        /// 
        /// </summary>
        private string m_ПутьПапкаСеансаЛога;
        /// <summary>
        /// Текущий файл лога, в который ведется запись.
        /// </summary>
        private ФайлЛога m_ТекущийФайлОбщегоЛога;
        /// <summary>
        /// Текущий файл лога, в который ведется запись.
        /// </summary>
        private ФайлЛога m_ФайлЛогаКонсоли;
        /// <summary>
        /// Текущий файл лога, в который ведется запись.
        /// </summary>
        private ФайлЛога m_ФайлЛогаНераспознанныхКоманд;

        /// <summary>
        /// Идентификатор сеанса движка, перенесен в СеансЛога
        /// </summary>
        /// <remarks>
        /// Тут он internal, чтобы можно было получить его из движка или менеджера лога.
        /// Хотя я не знаю, зачем он может потребоваться в движке, кроме собственно лога.
        /// Если при отладке Движка нигде не потребуется, поставить его в private
        /// </remarks>
        internal ИдентификаторСеансаДвижка m_ИдентификаторСеансаДвижка;
        //Можно ли вместо этого хранить тут просто Int64 код сеанса?

#endregion
        #region Поля исполнителя команд
        /// <summary>
        /// Завершить работу потока: true / false.
        /// </summary>
        private bool m_Stop;
        /// <summary>
        /// Поток исполнителя
        /// </summary>
        private Thread m_workingThread;
        /// <summary>
        /// Очередь заданий потока исполнителя
        /// </summary>
        private JobList m_joblist;

        #endregion


        /// <summary>
        /// NR-Конструктор
        /// </summary>
        /// <param name="man">Объект менеджера лога</param>
        public СеансЛога(LogManager man)
        {
            m_manager = man;
            
            this.m_СчетчикНомерФайлаЛога = 1;
            //исполнитель команд:
            m_Stop = true;//остановить исполнение потока

            return;
        }


        /// <summary>
        /// NR-открыть сеанс лога
        /// </summary>
        /// <param name="sid">ид сеанса движка</param>
        /// <param name="sett">настройки движка</param>
        internal void Open(OperatorSettings sett)
        {
            //1 установить переменные объекта
            //     * [//СчетчикФайловЛога] = 1
            this.m_СчетчикНомерФайлаЛога = 1;
            //2 создать идентификатор сеанса движка и лога для названий файлов лога и папки сеанса лога
            this.m_ИдентификаторСеансаДвижка = ИдентификаторСеансаДвижка.СоздатьНовыйИдентификатор();
            string sessionTitle = this.m_ИдентификаторСеансаДвижка.ToString();
            //3 создать новую ПапкаСеансаЛога и первый ФайлЛога в ней
            //-создать новую папку лога без индексирования, выдать исключение если это невозможно.
            this.m_ПутьПапкаСеансаЛога = Path.Combine(this.m_manager.КаталогЛогаОператора, sessionTitle);
            Utilities.СоздатьКаталогБезИндексирования(m_ПутьПапкаСеансаЛога);
            //-создать файл общего лога и вписать его текущим файлом лога в сеансе
            string filename = ФайлЛога.СоздатьИмяФайла(sessionTitle, this.getНовыйНомерФайлаЛога(), this.m_manager.Settings.РасширениеФайлаЛога);
            m_ТекущийФайлОбщегоЛога = ФайлЛога.Create(this.m_ПутьПапкаСеансаЛога, filename);
            //4 создать файл лога консоли
            //открыть файл лога консоли в каталоге сеанса лога
            this.m_ФайлЛогаКонсоли = ФайлЛога.Create(this.m_ПутьПапкаСеансаЛога, OperatorSettings.LogConsoleFileName + this.m_manager.Settings.РасширениеФайлаЛога);
            //5 создать файл лога нераспознанных команд
            //открыть файл лога в каталоге сеанса лога
            this.m_ФайлЛогаНераспознанныхКоманд = ФайлЛога.Create(this.m_manager.КаталогЛогаОператора, OperatorSettings.LogUnknownCmdFileName + this.m_manager.Settings.РасширениеФайлаЛога);
            
            //для потока исполнения: 
            //6 создать и инициализировать поток исполнения
            m_workingThread = new Thread(ThreadWork);
            m_Stop = false;//разрешить работу цикла
            m_joblist = new JobList();//создать очередь команд
            m_joblist.TooManyCommandsEvent += new EventHandler(m_joblist_TooManyCommandsEvent);
            //run thread
            m_workingThread.Start();//на однопроцессорной системе он запустится только после того, как текущий поток отработает свой квант (~20mS) 

            //вписать начальное сообщение в лог
            m_joblist.AddCommand(new CommandMessage(CommandMessageCode.AddLogMessage, new LogMessage(LogMessageCode.НачалоСеанса, "Сеанс лога начат: " + sessionTitle)));
            
            return;
        }


        /// <summary>
        /// NT-Закрыть сеанс лога
        /// </summary>
        internal void Close()
        {
            string sessionTitle = this.m_ИдентификаторСеансаДвижка.ToString();
            //Для потока исполнения:
            //вывести сообщение о завершении сеанса лога
            m_joblist.AddCommand(new CommandMessage(CommandMessageCode.AddLogMessage, new LogMessage(LogMessageCode.ЗавершениеСеанса, "Сеанс лога закончен: " + sessionTitle)));
            //отправить потоку команду завершить цикл работы
            //он должен и файлы лога закрыть при этом
            m_joblist.AddCommand(new CommandMessage(CommandMessageCode.FinishLogLoop));
            //ждать пока рабочий поток закончит работу
            m_workingThread.Join(60000);//wait for 60 seconds - для перегруженной системы 60 секунд достаточно будет
            //очистить очередь сообщений
            m_Stop = true; //на всякий случай?
            m_joblist.Close();//освободить ресурсы - семафор ядра
            
            return;
        }

        /// <summary>
        /// NT-Получить новый номер файла лога.
        /// </summary>
        /// <remarks>
        /// Это должна быть единственная функция получения нового номера файла лога.
        /// Только здесь выполняется инкремент счетчика файлов лога.
        /// </remarks>
        /// <returns></returns>
        internal Int32 getНовыйНомерФайлаЛога()
        {
            Int32 result = this.m_СчетчикНомерФайлаЛога;
            this.m_СчетчикНомерФайлаЛога = this.m_СчетчикНомерФайлаЛога + 1;
            return result;
        }

        /// <summary>
        /// NT-Добавить сообщение в файлы лога согласно классу сообщения
        /// </summary>
        /// <param name="msg">Объект сообщения лога</param>
        internal void AddMessage(LogMessage msg)
        {
            //добавить исполнителю команду записи сообщения в лог
            this.m_joblist.AddCommand(new CommandMessage(CommandMessageCode.AddLogMessage, msg));
            return;
        }

        /// <summary>
        /// NR-Создать новый файл лога, открыть для записи и сделать его текущим файлом лога
        /// </summary>
        /// <param name="новыйНомерФайлаЛога">Номер для нового файла лога</param>
        private void СоздатьСледующийФайлЛога(int новыйНомерФайлаЛога)
        {
            //    - создается новый ФайлЛога, добавляется в список файлов лога в объекте СеансЛога,
            //       и подготавливается к записи.
            //    - этот новый файл лога делается текущим в объекте СеансЛога. 

            
            //создать имя файла лога
            String filename = ФайлЛога.СоздатьИмяФайла(this.m_ИдентификаторСеансаДвижка.ToString(), новыйНомерФайлаЛога, this.m_manager.Settings.РасширениеФайлаЛога);
            ФайлЛога f = ФайлЛога.Create(m_ПутьПапкаСеансаЛога, filename);
            f.НомерФайла = новыйНомерФайлаЛога;
            //открыть файл для записи и чтения, перемотать позицию записи в конец файла - делается автоматически при следующей записи
            //сделать файл текущим
            m_ТекущийФайлОбщегоЛога = f;

            //вписать сообщение о продолжении сеанса лога - оно записывается уже в новый файл общего лога.
            f.ДобавитьСообщениеЛога(new LogMessage(LogMessageCode.ПродолжениеСеанса, "Продолжение сеанса " + m_ИдентификаторСеансаДвижка.ToString()));
            
            return;
        }

        /// <summary>
        /// NT-Закрыть все файлы лога по таймауту
        /// </summary>
        internal void CloseLogFilesByTimeout()
        {
            //Добавить сообщение о таймауте в лог
            this.m_joblist.AddCommand(new CommandMessage(CommandMessageCode.AddLogMessage, new LogMessage(LogMessageCode.ТребуетсяОпределить, "Файлы лога закрыты по таймауту")));
            //он сам выведет сообщение о исполнении в канал сообщений лога?
            //отправить команду в очередь команд исполнителя
            this.m_joblist.AddCommand(new CommandMessage(CommandMessageCode.CloseLogFiles));
            
            return;
        }


        #region Функции потока-исполнителя 

        /// <summary>
        /// NT-Рабочая функция потока
        /// </summary>
        protected void ThreadWork()
        {
            while (!m_Stop)
            {
                CommandMessage cmd = m_joblist.WaitCommand();
                //process command
                switch (cmd.Command)
                {
                    case CommandMessageCode.AddLogMessage:
                        //записать в файлы лога сообщение здесь
                        this._addLogMessage(cmd.Argument);
                        break;
                    case CommandMessageCode.CloseLogFiles:
                        this._closeAllLogFiles();//само сообщение о закрыти по таймауту уже отправлено и должно быть уже обработано
                        break;
                    case CommandMessageCode.FinishLogLoop:
                        m_Stop = true;//break while loop
                        this._closeAllLogFiles();//он должен и файлы лога закрыть при этом
                        break;
                    default:
                        //тут это значит, что код команды не будет обработан.
                        //это надо показать пользователю
                        this.m_manager.OnMessageAdded(new LogMessage(String.Format(CultureInfo.CurrentCulture, "Предупреждение: Неизвестный код команды исполнителю лога: {0}", cmd.Command)));
                        break;
                }
            }

            return;
        }
        /// <summary>
        /// NT-Закрыть все файлы лога
        /// </summary>
        private void _closeAllLogFiles()
        {
            this.m_ТекущийФайлОбщегоЛога.Close();
            this.m_ФайлЛогаКонсоли.Close();
            this.m_ФайлЛогаНераспознанныхКоманд.Close();
            return;
        }

        /// <summary>
        /// NT-функция сортировки и вывода сообщений в файлы лога
        /// </summary>
        /// <param name="p"></param>
        private void _addLogMessage(object p)
        {
            if (p == null)
                throw new Exception("Ошибка. Сообщение не может быть null");
            
            LogMessage msg = (LogMessage)p;
            LogMessageCode code = msg.MsgCode;
            //определить, куда писать сообщение лога
            if (code == LogMessageCode.ВводКонсолиНеизвестнаяКоманда)
            {
                //писать в файл неизвестных команд
                this.m_ФайлЛогаНераспознанныхКоманд.ДобавитьСообщениеЛога(msg);
            }
            if ((code == LogMessageCode.ВводКонсолиНеизвестнаяКоманда)
                || (code == LogMessageCode.ВводКонсолиРаспознаннаяКоманда)
                || (code == LogMessageCode.ВводКонсолиДиалог)
                || (code == LogMessageCode.ВыводКонсоли)
                || (code == LogMessageCode.НачалоСеанса)
                || (code == LogMessageCode.ЗавершениеСеанса))
            {
                //писать в файл лога консоли
                this.m_ФайлЛогаКонсоли.ДобавитьСообщениеЛога(msg);
            }
            //в общий лог писать все сообщения
            this._addMessage(msg);

            //отправить входное сообщение в канал обратных сообщений лога
            this.m_manager.OnMessageAdded(msg);

            return;
        }
        /// <summary>
        /// NT-Обработчик сообщений от очереди команд лога
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_joblist_TooManyCommandsEvent(object sender, EventArgs e)
        {
            //перенаправляет событие в канал сообщений лога.
            this.m_manager.OnMessageAdded(new LogMessage(LogMessageCode.ТребуетсяОпределить, "Внутренняя очередь сообщений лога переполнена."));
        }

        /// <summary>
        /// NT-Добавить сообщение в файлы лога согласно классу сообщения
        /// Исполняется потоком-исполнителем
        /// </summary>
        /// <param name="msg">Объект сообщения лога</param>
        internal void _addMessage(LogMessage msg)
        {
            //тут где-то надо перед созданием нового файла лога
            //проверить остаток свободного места на томе
            //и если он меньше предельного размера файла,
            //то удалить самый старый сеанс лога из имеющихся в каталоге лога
            //а если таких нет, кроме текущего, то выдать исключение "Недостаточно места на диске".
            //и завершить работу приложения.
            //и сообщения в обратный канал лога выдавать по ходу этой работы.

            //Ход работы:
            //1 проверить что размер файла общего лога менее установленного предела
            //если более предела, то:
            //1.1 закрыть текущий файл лога
            //1.2 создать новый номер файла лога
            //1.3 если число файлов лога превышает установленный предел (999),то выдать исключение и завершить работу программы
            //1.4 проверить размер свободного места на диске.
            //1.4.1 если размер свободного места менее предельного размера файла лога, то:
            //1.4.1.1 если есть более старые каталоги сеансов лога, то:
            //1.4.1.1.1 удалить самый старый каталог сеанса лога.
            //1.4.1.1.2 перейти к пункту 1.4.1
            //1.4.2 если размер свободного места менее предельного размера файла лога, и нет более старых сеансов лога, 
            //то выдать исключение О исчерпании свободного места для файлов лога, и завершить работу программы.
            //1.4.3 иначе (если место есть):
            //1.4.4 создать новый файл лога, вписать его в сеас лога текущим, вывести сообщение о продолжении сеанса,
            //записать в файл новое сообщение.

            //- проверяется, что позиция записи (размер файла лога) менее установленного предела.
            //  Этот предел хранится в настройках МенеджерЛога и передается в СеансЛога при инициализации СеансЛога.
            //  Для этого вызывается функция ФайлЛога.ПолучитьПозициюЗаписиВКонецФайла для Текущего ФайлЛога сеанса лога.
            //  Функция возвращает Int64 позицию записи в файл лога.
            Int64 limit = (Int64)this.m_manager.Settings.ПределРазмераФайлаЛогаМб * (1024*1024);//предел хранится в мегабайтах
            Int64 size = m_ТекущийФайлОбщегоЛога.ПолучитьРазмерФайла();
            //- Если размер текущего ФайлЛога более установленного предела, то:
            //  - Этот ФайлЛог закрывается.
            if (size > limit)
            {
                //ЗакрытьТекущийФайлЛога перед открытием следующего файла лога
                //- вписать сообщение о продолжении сеанса лога с кодом ПродолжениеЛога
                this.m_ТекущийФайлОбщегоЛога.ДобавитьСообщениеЛога(new LogMessage(LogMessageCode.ПродолжениеСеанса, "Продолжение сеанса " + this.m_ИдентификаторСеансаДвижка.ToString()));
                //- закрыть файл лога
                this.m_ТекущийФайлОбщегоЛога.Close();

                //  - Если число файлов лога в сеансе более установленного предела в 999 шт, то выдается 
                //    исключение EngineArchitectureException с пояснительным текстом о том, что предел 
                //    в 999 файлов сеанса лога достигнут и движок должен быть остановлен.
                Int32 новыйНомерФайлаЛога = this.getНовыйНомерФайлаЛога();
                if (новыйНомерФайлаЛога > this.m_manager.Settings.ПределКоличестваФайловЛогаВСеансе)
                    throw new EngineArchitectureException("Превышен предел числа файлов лога в сеансе");
                //else
                //1.4 проверить размер свободного места на диске.
                //1.4.1 если размер свободного места менее предельного размера файла лога, то:
                //1.4.1.1 если есть более старые каталоги сеансов лога, то:
                //1.4.1.1.1 удалить самый старый каталог сеанса лога.
                //1.4.1.1.2 перейти к пункту 1.4.1
                //1.4.2 если размер свободного места менее предельного размера файла лога, и нет более старых сеансов лога, 
                //то выдать исключение О исчерпании свободного места для файлов лога, и завершить работу программы.

                //if (!СеансЛога.ОсвободитьМестоДляНовогоФайлаЛога(this.m_manager.Settings.ПределРазмераФайлаЛогаМб * 1024 * 1024, this.m_manager.КаталогЛогаОператора, this.m_ИдентификаторСеансаДвижка))
                //первая версия не контролировала общий размер лога Оператора.
                //вторая версия контролирует общий размер лога Оператора
                if(!СеансЛога.ОсвободитьМестоДляНовогоФайлаЛога2(this.m_manager.Settings, this.m_ИдентификаторСеансаДвижка.ToString(), this.m_manager.КаталогЛогаОператора))
                {
                    //не удалось освободить место для нового файла лога
                    throw new EngineArchitectureException("Недостаточно места для файлов лога");
                }
                else
                {
                    //1.4.3 иначе (если место есть):
                    //1.4.4 создать новый файл лога, вписать его в сеас лога текущим, вывести сообщение о продолжении сеанса,

                    this.СоздатьСледующийФайлЛога(новыйНомерФайлаЛога);
                    //  - Иначе: 
                    //    - создается новый ФайлЛога, добавляется в список файлов лога в объекте СеансЛога,
                    //       и подготавливается к записи.
                    //    - этот новый файл лога делается текущим в объекте СеансЛога.  
                }
            }
            //- передается в текущий ФайлЛога.ДобавитьЗапись(ЗаписьЛога).
            //Файл лога надо заново открыть, если он был закрыт по таймауту
            //Текущий ФайлЛога хранится в переменной в СеансЛога.
            //2 записать в файл новое сообщение.
            //вписать запись в файл лога
            m_ТекущийФайлОбщегоЛога.ДобавитьСообщениеЛога(msg);

            return;
        }

        ///// <summary>
        ///// NT-Освободить место на диске, если его недостаточно.
        ///// Предполагает, что каталог текущего сеанса уже создан.
        ///// Первая версия, заполняет логом все свободное место на диске
        ///// Заменена на вторую версию, но пока осталась в проекте до конца отладки
        ///// </summary>
        ///// <param name="filesize">Требуемый размер свободного места на диске в байтах</param>
        ///// <param name="logFolder">Каталог, содержащий удаляемые подкаталоги. Только абсолютный путь.</param>
        ///// <param name="sid">Текущий сеанс лога - название папки, которую нельзя удалять</param>
        ///// <returns>Возвращает true если место удалось выделить, иначе false</returns>
        //private static bool ОсвободитьМестоДляНовогоФайлаЛога(long filesize, string logFolder, ИдентификаторСеансаДвижка sid)
        //{
        //    //TODO: Отладка - тут много кода, надо проверить и оптимизировать его.
        //    //вообще, эта функция неправильная - ее реализация предполагает, что все свободное место на диске будет отдано на Лог Оператора.
        //    //Надо сразу переделать все это так, чтобы лог был ограничен определенным общим размером лога, и в пределах его распоряжался дисковым местом.
        //    //Для этого надо переделывать всю эту ветвь управления сеансами и файлами.
        //    //Но сейчас мне не хочется это делать. 

        //    //1.4 проверить размер свободного места на диске.
        //    //1.4.1 если размер свободного места менее предельного размера файла лога, то:
        //    //1.4.1.1 если есть более старые каталоги сеансов лога, то:
        //    //1.4.1.1.1 удалить самый старый каталог сеанса лога.
        //    //1.4.1.1.2 перейти к пункту 1.4.1

        //    //1.4 проверить размер свободного места на диске.
        //    //string volume = Utility.Utilities.ИзвлечьБуквуТомаДискаИзПути(logFolder);
        //    string root = Path.GetPathRoot(logFolder);
        //    Int64 size = Utility.Utilities.ПолучитьРазмерСвободногоМестаНаТоме(root);
        //    //1.4.1 если размер свободного места менее предельного размера файла лога, то:
        //    //быстрый выход если места достаточно
        //    if (size >= filesize)
        //        return true;
        //    //получить подкаталоги каталога лога
        //    String[] folders = Directory.GetDirectories(logFolder);
        //    //быстро выйти если каталог сеанса только один - текущий
        //    if (folders.Length < 2)
        //        return false;
        //    //создать и заполнить список путей прошлых сеансов лога, сортированный по дате
        //    //удалить из него текущий сеанс лога
        //    List<string> lis = new List<string>();
        //    String sidname = sid.ToString();//TODO: сюда лучше было передать путь текущего сеанса а не идентификатор.
        //    foreach (String f in folders)
        //    {
        //        string name = Path.GetFileName(f);//get folder title
        //        if (!String.Equals(sidname, name, StringComparison.OrdinalIgnoreCase))
        //            lis.Add(f);
        //    }
        //    //сортировать по названию - лучше по дате
        //    lis.Sort();//TODO: Отладка - проверить что сортировка по дате происходит правильно
        //    //удалить каталоги до достижения требуемого размера свободного места
        //    foreach (String ff in lis)
        //    {
        //        Directory.Delete(ff, true);
        //        size = Utility.Utilities.ПолучитьРазмерСвободногоМестаНаТоме(root);
        //        if (size >= filesize)
        //            break;
        //    }
        //    //1.4.2 если размер свободного места менее предельного размера файла лога, и нет более старых сеансов лога,
        //    //то выдать исключение О исчерпании свободного места для файлов лога, и завершить работу программы.
        //    if (size < filesize)
        //        return false;
        //    else return true;
        //}


        /// <summary>
        /// NT-Освободить место на диске, если его недостаточно.
        /// Предполагает, что каталог текущего сеанса уже создан.
        /// Это версия с ограничением общего размера лога
        /// </summary>
        ///<param name="set">Объект настроек Оператора</param>
        /// <param name="sidname">Идентификатор текущего сеанса лога - название папки, которую нельзя удалять</param>
        /// <returns>Возвращает true если место удалось выделить, иначе false</returns>
        private static bool ОсвободитьМестоДляНовогоФайлаЛога2(OperatorSettings set, String sidname, String logFolderPath)
        {
            //TODO: Отладка - тут много кода, надо проверить и оптимизировать его.
            Int64 logFileSize = set.ПределРазмераФайлаЛогаМб * (1024 * 1024);
            String root = Path.GetPathRoot(logFolderPath);

            //1 получить макс размер каталога лога из настроек Оператора, в байтах
            Int64 maxLogFolderSize = set.ПределРазмераКаталогаЛогаМб * (1024 * 1024);
            //2 получить размер свободного места на диске
            Int64 volumeFreeSize = Utility.Utilities.ПолучитьРазмерСвободногоМестаНаТоме(root);
            //3 получить реальный размер каталога лога Оператора
            Int64 logFolderRealSize = Utility.Utilities.GetDirectorySize(logFolderPath);
            //4 вычислить доступное место как минимум из п2 и п1-п3
            Int64 availableDiskSpace = Math.Min(volumeFreeSize, maxLogFolderSize - logFolderRealSize);
            //из-за файлов помимо файлов общего лога мы промахиваемся мимо предела и результат получается отрицательным 
            //то есть, превышаем пределы общего размера лога. И это никак не предусмотреть здесь. 
            //5 если этот размер больше размера нового файла лога, вернуть успех.
            if (availableDiskSpace > logFileSize) return true;
            //иначе:
            //6 Получить список сеансов лога и удалить из него текущий сеанс лога.
            //получить подкаталоги каталога лога
            String[] folders = Directory.GetDirectories(logFolderPath);
            //быстро выйти если каталог сеанса только один - текущий
            if (folders.Length < 2)
                return false;
            //создать и заполнить список путей прошлых сеансов лога, сортированный по дате
            //удалить из него текущий сеанс лога
            List<string> lis = new List<string>();
            //TODO: сюда лучше было передать путь текущего сеанса а не идентификатор.
            foreach (String f in folders)
            {
                string name = Path.GetFileName(f);//get folder title
                if (!String.Equals(sidname, name, StringComparison.InvariantCultureIgnoreCase))
                    lis.Add(f);
            }
            //7 сортировать список сеансв лога по дате-названию
            //(более старые снансы должны быть в начале списка) 
            lis.Sort();//TODO: Отладка - проверить что сортировка по дате происходит правильно
            //8 вычислить место, которое требуется дополнительно освободить для файла: д = размер нового файла лога - п4
            //наоборот, если availableDiskSpace отрицательное, то размер освобождаемого пространства надо увеличить на это значение.
            //тут дельта должна быть отрицательной
            Int64 delta = availableDiskSpace - logFileSize;
            //9 в цикле для всех сеансов из списка: начиная с более старых
            foreach (String ff in lis)
            {
                //9.1 вычислить размер сеанса в байтах
                Int64 sessionFolderSize = Utility.Utilities.GetDirectorySize(ff);
                //9.2 д = д + п9.1
                delta = delta + sessionFolderSize;
                //9.3 удалить эту папку сеанса лога
                Directory.Delete(ff, true);
                //9.4 если д > размер нового файла лога, то break (выходим из цикла)
                //нет, тут дельта должна стать больше 0
                if (delta > 0)
                    break;
            }
            //тут мы либо нащли место для файла, либо поудаляли все сеансы, но не освободили достаточное место.
            //10 получить размер свободного места на диске
            volumeFreeSize = Utility.Utilities.ПолучитьРазмерСвободногоМестаНаТоме(root);
            //11 получить реальный размер каталога лога Оператора
            logFolderRealSize = Utility.Utilities.GetDirectorySize(logFolderPath);
            //12 вычислить доступное место как минимум из п10 и п1-п11
            availableDiskSpace = Math.Min(volumeFreeSize, maxLogFolderSize - logFolderRealSize);
            //13 если этот размер больше размера нового файла лога, вернуть успех.
            if (availableDiskSpace > logFileSize) return true;
            //иначе вернуть облом
            else return false;
        }


        #endregion



    }
}
