Это старый файл, во время начала проектирования разработанной подсистемы лога.
Отсюда можно извлечь полезные факты, но тут их мало.
Лучше удалить этот файл, после переработки материалов. 

Это кусок разбора устройства лога из моего проекта Оператор.
В нем нужен лог, но не такой сложный.
Нужны некоторые куски отсюда:
-управление файлами внутри сеанса лога
-файловая система лога
-загрузка настроек движка
-добавление сообщения в файл лога
-ограничение размера файла лога

У Оператор есть особенности, отличные от Тапп:
- Оператор работает на компьютере постоянно. Тапп - только в рамках приложения.
- Оператор многопоточный сам по себе. В коде Тапп многопоточность не рассматривается сейчас.
- Тапп многопользовательский. Его лог - сложный двоичный древовидный. Лог Оператора представляет собой простую последовательность XML-записей. 

Код Тапп лога еще не завершен, но я надеюсь хоть что-то полезное получить отсюда.
Вот код этого класса надо изучить для переноса в Оператор: СеансЛога, ФайлЛогаСолюшена, 
Причем код не доделан, не тестировался, разработка остановлена, как обычно, после выяснения всех проблемных мест. А теперь эти знания забылись и все это надо заново начинать.



1 сначала создается объект НастройкиСолюшена. Он хранит настройки солюшена, и в том числе свойства лога.
Он загружается настройками из файла, тут это из настроек приложения.
Затем эти значения проверяются на допустимость.
Если настройки (значения) неправильные, выдаются исключения.
Поля:
-public string КаталогЛога
-public string КаталогСолюшена
-public string РасширениеФайлаЛога
-public long ПределРазмераФайлаЛога
-public int ПределКоличестваФайловЛогаВСеансе

2 создаем идентификатор сеанса движка для инициализации лога и других подсистем
ИдентификаторСеансаДвижка - класс можно весь импортировать.
Это строка, получаемая из текущего значения даты-времени.

3 создаем объект менеджера лога - подсистемы лога.
m_LogManager = new МенеджерЛога(this, settings);
- в менеджер вписывается обратная ссылка на движок
- создается объект ВерсияПодсистемыЛога из номера версии лога, из константы менеджера
- поля класса: придется частично импортировать в мой проект.
        /// <summary>
        /// Константа версия подсистемы лога. Хранится здесь как в специальном месте для констант подсистемы лога.
        /// </summary>
        public const string СтрокаВерсииПодсистемыЛога = "1.0.0.0";
        /// <summary>
        /// Объект версии подсистемы лога - держим постоянно тут, чтобы проверять на совместимость 
        /// все места, где используется версия подсистемы лога. 
        /// </summary>
        internal ВерсияПодсистемыЛога m_ВерсияПодсистемыЛога;
        /// <summary>
        /// Значение из НастройкиСолюшена, здесь кешируется.
        /// </summary>
        private string m_КаталогЛоговСолюшена; //Можно просто получать это значение из объекта НастройкиСолюшена в Движок
        /// <summary>
        /// Текущий сеанс лога как ПапкаСеансаЛога
        /// </summary>
        private СеансЛога m_текущийСеансЛога;
                /// <summary>
        /// Идентификатор сеанса движка, также хранится в объекте Движок
        /// </summary>
        private ИдентификаторСеансаДвижка m_ИдентификаторСеансаДвижка;
        //Можно ли вместо этого хранить тут просто Int64 код сеанса?
        
4 инициализируем менеджер лога
m_LogManager.Initialize(engineSessionId, settings);//или объединить с конструктором?
-Идентификатор сеанса движка вписываем в поле.
-каталог лога вписываем в поле
-создаем объектсеанса лога и открываем сеанс лога
            СеансЛога sel = new СеансЛога(this.m_engine);
            sel.Create(engineSessionId, m_КаталогЛоговСолюшена, settings);
-вписываем сеанс лога в поле

4.1 СеансЛога объект представляет собственно управление сеансом лога. 
Сеанс состоит из нескольких файлов лога. Управляет размером файлов лога.
Поля:
/// <summary>
        /// Счетчик номера файла лога в текущем сеансе Лога и Движка.
        /// </summary>
        private Int32 m_СчетчикНомерФайлаЛога;
        /// <summary>
        /// Счетчик идентификатора записи лога в текущем сеансе Лога и Движка.
        /// </summary>
        private Int32 m_СчетчикИдентификаторЗаписиЛога;
        /// <summary>
        /// Ссылка на объект движка
        /// </summary>
        private Движок m_engine;

        /// <summary>
        /// Идентификатор сеанса движка, также хранится в объекте Движок
        /// </summary>
        private ИдентификаторСеансаДвижка m_ИдентификаторСеансаДвижка;
        //Можно ли вместо этого хранить тут просто Int64 код сеанса?

        private string m_ПутьПапкаСеансаЛога;
        /// <summary>
        /// Текущий файл лога, в который ведется запись.
        /// </summary>
        private ФайлЛогаСолюшена m_ТекущийФайлЛога;
        /// <summary>
        /// Расширение файла лога, без точки
        /// </summary>
        private string m_РасширениеФайлаЛога;

Конструктор: недоделан, явно код не тестировался
        public СеансЛога(Движок engine)
        {
            //вписать ссылку на движок
            this.m_engine = engine;
            //     * [//СчетчикИдентификатораЗаписиЛога] = 1
            m_СчетчикИдентификаторЗаписиЛога = 1;
            //     * [//СчетчикФайловЛога] = 1
            m_СчетчикНомерФайлаЛога = 1;
            
            throw new System.NotImplementedException();
        }

4.2 функция создания нового сеанса:
        /// <summary>
        /// NR-Создать новый СеансЛога
        /// </summary>
        /// <param name="engineSessionId"></param>
        /// <param name="каталогЛоговСолюшена"></param>
        /// <param name="settings"></param>
        internal void Create(ИдентификаторСеансаДвижка engineSessionId, string каталогЛоговСолюшена, НастройкиСолюшена settings)
        {
            //     * [//СчетчикИдентификатораЗаписиЛога] = 1
            m_СчетчикИдентификаторЗаписиЛога = 1;
            //     * [//СчетчикФайловЛога] = 1
            m_СчетчикНомерФайлаЛога = 1;
            //копировать значения переменных из настроек
            this.m_ИдентификаторСеансаДвижка = engineSessionId;
            this.m_РасширениеФайлаЛога = settings.РасширениеФайлаЛога;
            //-создать новую ПапкаСеансаЛога и первый ФайлЛога в ней
            //--создать новую папку лога без индексирования, выдать исключение если это невозможно.
            string newSessionFolderName = engineSessionId.ToString();
            m_ПутьПапкаСеансаЛога = Path.Combine(каталогЛоговСолюшена, newSessionFolderName);
            Utilities.СоздатьКаталогБезИндексирования(m_ПутьПапкаСеансаЛога);
            //--создать файл лога и вписать его текущим файлом лога в сеансе
            string filename = ФайлЛогаСолюшена.СоздатьИмяФайла( engineSessionId.ToString(), this.getНовыйНомерФайлаЛога(), this.m_РасширениеФайлаЛога);
            m_ТекущийФайлЛога = ФайлЛогаСолюшена.Create(каталогЛоговСолюшена, filename);
            m_ТекущийФайлЛога.OpenForWriting();
            //-вывести в лог сообщение о начале СеансДвижка.

            throw new NotImplementedException();//TODO: Add code here...
        }

Вот код этого класса надо изучить для переноса в Оператор.


0. Добавить запись лога в лог функцией
        /// <summary>
        /// NT-Добавить ЗаписьЛога в лог
        /// Возвращает идентификатор добавленной записи лога.
        /// Выбрасывает исключение при любой ошибке.
        /// </summary>
        /// <param name="z">Заполненный объект ЗаписьЛога</param>
        /// <returns>Возвращает Идентификатор добавленной записи лога.</returns>
        internal ИдентификаторЗаписиЛога ДобавитьСообщениеЛога(КонсольПользователя con, ЗаписьЛога z)
        {
            //а где вообще должны быть функции записи в лог?
            //надо проектировать снизу вверх теперь?
            return this.m_текущийСеансЛога.ДобавитьСообщениеЛога(con, z);
        }
Тут тоже вся нужная мне работа делается в классе СеансЛога.

0. Закрываем сеанс лога
this.m_текущийСеансЛога.Close(); - этот код не реализован.


Файловая система:
-КаталогОператора
--Файл настроек Оператора
--исполняемые файлы Оператора
--БД Оператора
--КаталогЛога
---Файл нераспознанных команд, дополняется
---КаталогСеансаЛога
----Файл лога Оператора - много за сеанс
----Файл лога консоли - один за сеанс.


Какие классы импортировать:
- СеансЛога - обслуживает КаталогСеансаЛога
- ФайлЛогаСолюшена - расширить им уже существующий класс записи в ХМЛ.
- МенеджерЛога - выборочно некоторые поля и функции взять в существующий класс Оператора.
- ИдентификаторСеансаДвижка - взять почти целиком без переработки
- НастройкиСолюшена - внести востребованные поля в НастройкиОператора. 
- функции инициализации солюшена из Движок.
- LogMessageChannelEventArgs импортировать полностью
- Utilities функции импортировать или включить в мою библиотеку классов.
  - а библиотеку тогда включить в проект Оператор.


Общие сведения о классах:
* Лог структурно можно представить как упорядоченный по хронологии поток СообщениеЛога, 
 разделенный на ФайлЛогаСолюшена, группированные в сеансы СеансЛога.

ВерсияПодсистемыЛога
-хранит версию подсистемы лога для различения версий подсистемы лога в будущем.
-начальное значение версии 1.0


НастройкиСолюшена
-это класс-хранилище настроек. 
В этой тестовой модели он просто хранит настройки и константы итп, 
сохраняя значения в настройках приложения.
Он тут нужен для того, чтобы не искать потом по всем файлам эти настройки и константы.


Движок
-представляет весь движок в целом.
-вероятно, это просто контейнер для различных подсистем. 
Но пользователь работает именно с ним, как с единым объектом.

ИдентификаторСеансаДвижка
-Полный синоним ИдентификаторСеансаЛога.
-Представляет СеансДвижка от открытия Солюшена до его закрытия.
-ИдентификаторСеансаДвижка создается при инициализации сеанса Движка. Вероятно, в МенеджерСолюшена.
-ИдентификаторСеансаДвижка передается в МенеджерЛога при инициализации менеджера.
-данные:
--поле и проперти Int64 КодСеансаДвижка
-функции:
--static obj СоздатьНовыйИдентификатор() - производится из текущего времени системных часов.
--string ToString() - Шаблон ГГГГММДД-ЧЧММСС
--bool Parse(string) - распарсить из строки, вернуть false если неправильный формат.


МенеджерЛога
-управляет всей подсистемой лога. Входит в состав Движок.

СеансЛога (см. вики КлассСеансЛога)
-синоним СеансДвижка.
-представляет СеансЛога как объект.
-В ФайловаяСистемаСолюшена представлен как ПапкаСеансаЛога.
* [//КлассСеансЛога/Конструктор]
* [//КлассСеансЛога/ПолеИдентификаторСеансаДвижка] - идентификатор сеанса движка.
* [//КлассСеансЛога/ПолеПутьПапкиСеансаЛога] - путь к папке ПапкаСеансаЛога.
* [//КлассСеансЛога/ПолеКоллекцияФайловЛога] - объект коллекции ФайлЛогаСолюшена данного СеансЛога. Сортированный по НомерФайлаЛога.
* [//КлассСеансЛога/ЗаполнитьКоллекциюФайловЛога] - перечитать файлы в ПапкаСеансаЛога и сортировать по НомерФайлаЛога.
* [//КлассСеансЛога/СоздатьФайлЛога]  - создать новый ФайлЛогаСолюшена и КлассФайлЛога и добавить его в коллекцию файлов лога.
* [//КлассСеансЛога/ИтераторСеансаЛога] - итератор для файлов и записей лога. 
* [//КлассСеансЛога/СоздатьСеансЛога] - создать новый сеанс лога как текущий сеанс лога.
* [//КлассСеансЛога/ЗавершитьСеансЛога] - завершить сеанс лога, когда он текущий сеанс.
* [//КлассСеансЛога/УдалитьСеансЛога] - удалить текущий сеанс лога, ПапкаСеансаЛога и все его файлы.
* [//КлассСеансЛога/ПолеТекущийФайлЛога] (?)- экземпляр файла лога, в котором сейчас ведется чтение.

* Лог семантически можно представить как упорядоченный по хронологии поток СообщениеЛога, организованные в Транзакции, разделенный на ФайлЛогаСолюшена, группированные в сеансы СеансЛога.
* СеансЛога в подсистеме лога является синонимом СеансДвижка.
* СеансДвижка имеет начало и конец, которые должны обозначаться записями в файле лога.
    * Нужны СообщениеЛога о начале и о конце СеансДвижка. 
* Лог управляет (удаляет файлы ФайлЛогаСолюшена) только блоками - сеансами Движка (СеансЛога).
* Хранящиеся в Солюшене СеансЛога можно быстро определить, проверив имена папок в КаталогЛоговСолюшена. Папки, чье название соответствует шаблону ИдентификаторСеансаДвижка, считаются ПапкаСеансаЛога.
* СеансЛога представляет собой совокупность связанных между собой ФайлЛога. Потеря одного из ФайлЛога повредит целостность всего СеансЛога. 
* Хранящиеся в Солюшене СеансЛога можно быстро определить, проверив имена папок в КаталогЛоговСолюшена. Папки, чье название соответствует шаблону ИдентификаторСеансаДвижка, считаются ПапкаСеансаЛога.

* Файлы ФайлЛогаСолюшена создавать в пределах СеансДвижка.
    * Так проще будет удалять файлы. По границам сеанса.
    * Целесообразно удалять не отдельные файлы, а целиком СеансЛога, так как точки между сеансами предполагается сохранять в  ПолныйСнимокСтруктуры. И туда можно откатиться, просто загрузив этот ФайлПолногоСнимка.
        * Но создание ПолныйСнимокСтруктуры не должно автоматически приводить к закрытию сеанса и созданию нового СеансЛога. Снимок может быть сделан с другими целями, а не как ТочкаСохранения СтруктураСущностей.



ФайлЛогаСолюшена (см. вики КлассФайлЛога)
- хранит записи о событиях в [Солюшен]е в течение СеансЛога (СеансДвижка).
- Рассматривается ДвоичныйФайлЛога только.
* ФайлЛогаСолюшена содержит ШапкаФайлаЛога и последовательность ЗаписьЛога.
* Группировку записей по СеансПользователя (по ИдентификаторСеансаПользователя) делает код из ИнтерпретаторЛога. Он превращает ЗаписьЛога в объекты и выдает их вызывающему коду.
* Фактически, файл лога это база данных, с быстрой вставкой и медленным получением.
Совсем сделать его на БД вроде sqlite нельзя, так как БД будет жрать память процесса (На индексы, кеши запросов, итд), а ее всегда не хватает.
    * С механизмом транзакций и многопользовательской концепцией это уже не набор независимых записей, а дерево транзакций. Все файлы лога связаны друг с другом ссылками от более поздних к более ранним записям.
* Обработка и поиск в логе будут медленными, но это и не предполагается часто использовать.
* ФайлЛогаСолюшена представлен некоторым С#-классом, который выполняет работы, относящиеся к файлам лога и их содержимому.
* Все ФайлЛогаСолюшена текущего СеансЛога должны храниться в соответствующей ПапкаСеансаЛога.
* НомерФайлаЛога это порядковый номер ФайлЛогаСолюшена внутри СеансЛога (ПапкаСеансаЛога).
    * НомерФайлаЛога начинается с 1. Это целое число от 000 до 999, дополнять нулями до 3 знаков. Его следует хранить в памяти МенеджерЛога, назначать = 1 при создании СеансДвижка и инкрементировать при создании нового файла лога внутри сеанса. Это проще, чем извлекать его из имен файлов (другой способ).
* см вики НазваниеФайлаЛога для создания и разбора имени файла лога.
* Для генерации и парсинга НазваниеФайлаЛога нужны статические функции ФайлЛогаСолюшена:
    * Создать НазваниеФайлаЛога по ИдентификаторСеансаДвижка и НомерФайлаЛога и РасширениеФайловЛога из НастройкиСолюшена.
    * Извлечь ИдентификаторСеансаДвижка и НомерФайлаЛога из НазваниеФайлаЛога.
    * Проверить, что указанная строка соответствует формату НазваниеФайлаЛога, является НазваниеФайлаЛога. Соответственно, файл является ФайлЛогаСолюшена. 

Записи по ходу проекта:
  - СеансЛога как объект не нужен вроде бы - его работу будет делать менеджерЛога?
    - теоретически, Сеанс хранит данные за сеанс. Но практически, менеджер лога может делать всю эту работу.
      - Сеанс лога отвечает только за свой сеанс, свои файлы лога. 
        Менеджер лога работает со всеми сеансами лога в целом. Поэтому всю работу надо разделить в разные классы. 
   - Версия подсистемы лога - нужен как объект. Но его вообще-то можно создавать по факту требования.
    - это не важная часть системы. Достаточно будет обозначить его функции.
    - он используется редко.
    - он должен хранить константу версии и методы проверки версий.
      - константа версии помещена в МенеджерЛога как общее место для всех констант подсистемы лога.
    - константу версии надо представлять статическим членом(ами)?
      - нет, так как это объект версии, и могут существовать другие объекты версий, например, из файлов лога.
        И их нужно сравнивать между собой, чтобы определить их поддерживаемость подсистемой лога.
  - управление папками и файлами лога: 
    - где размещать функции?
      - в менеджере лога, конечно, пока больше негде.
    - папки и файлы должны быть сведены в дерево и для перемещения по ним должен использоваться ИтераторЛога.
      - где должно размещаться это дерево?
      - где должны размещаться функции итератора?
    - дерево файлов лога сразу надо все предварительно читать, или по запросу итератора?     
  - для вывода сообщений в лог пока вообще нет функции - даже неясно, где она будет и как работать.
    - Это функция менеджера лога. Она принимает объект записи лога с значениями, но без идентификатора записи лога.
       И сама дополняет все что нужно и отправляет на запись в текущий файл лога.
       Больше пока об этом ничего не надо знать. Потом видно будет, что и как там работает.  
       
 - СеансЛога управляет ПапкаСеансаЛога и всем ее содержимым.
  - в него перенесены счетчики файлов и записей со всеми их функциями.
- МенеджерЛога управляет всеми ПапкаСеансаЛога и включает в себя ИтераторЛога по всем этим папкам.
- Тема: ограничение размера файла лога - как реализовать и какие проблемы?
  - максимальный размер файла лога: от 64мб до 2гб? По умолчанию 1 Гб.
- Перенести это в концепцию!!! Это вопрос архитектуры Движка.
  Тема: что делать, если количество файлов лога уже достигло 999, а сеанс еще не закончен?
  - это может произойти, если предел размера файла лога слишком маленький. Или если сеанс Движка очень большой.
  - расчет был на то, что этого не произойдет, так как 999 файлов лога размером 1Гб каждый - заполнят любой винт.
    - но сейчас варьируется ограничение размера файлов лога - они могут быть и по 64мб.
      - тогда стоп машина - сеанс движка не получится пересоздать в этой архитектуре. Наверно.
    - а если произошло, то что - останавливаем сеанс Движка и сохраняем данные?
      Для этого нужен специальный механизм.
  - надо завершать сеанс лога и открывать новый. Лучше это сделать незаметно для остального Движка.
    - это нельзя сделать так просто - ПапкаСеансаЛога называется по ИдентификаторСеансаДвижка, а он не изменился.
      Значит, ПапкаСеансаЛога не может быть создана. Нужно изменить ИдентификаторСеансаДвижка - перезапустить весь Движок.
      А к нему подключены пользователи, это непросто. 
      - можно сгенерировать новый ИдентификаторСеансаДвижка и заменить его везде, а сеанс лога перезапустить.
        Тогда в логе будут неправильная структура - сеанс лога закрыт, а сеанс Движка - нет, и состояние ячеек переходит в новый сеанс лога.
      - короче, тут надо перезапустить СеансДвижка, не отключив пользователей. Сейчас проще просто завершить сеанс 
        из-за переполнения лога и предложить пользователю увеличить размер файлов лога.         
  - а как передать сигнал об этом остальному коду от места проверки?
    - источник сигнала - функция создания номера файла или функция создания нового файла взамен старого?
    - внутри СеансЛога нужна функция выхода из СеансЛога в МенеджерЛога для перезапуска СеансЛога.
      Как это сделать?
      - при каждом сообщении входящем в МенеджерЛога, проверять, не требуется ли уже перезапуск СеансЛога.
        - но тут ИдентификаторСеансаДвижка нужен новый. А для этого надо перезапустить весь Движок.  
  - Лучшее решение сейчас:
    - при достижении предела в 999 файлов на СеансЛога выбрасывать исключение ПроблемаАрхитектурыДвижка.
    - и не думать более о этой проблеме, отложив ее до более позднего релиза, который возможно и не состоится.
  - Решение на будущее:  
    - ПапкаСеансаЛога называть по СеансДвижка плюс номер СеансаЛога.
    - счетчик номера сеанса лога вести подобно счетчику номера файла лога.
    - пересоздавать сеансЛога при  создании нового файла лога из-за превышения размера файла лога.
      Если номер файла лога более 999, то создавать новый СеансЛога с новой папкой, и вот в него очередную поступившую запись лога записывать.
    - включить номер сеанса лога в название файла лога так же, как сейчас он формируется из названия ПапкаСеансаЛога.
    - Движок не перезапускать, подсистема лога просто создает новый СеансЛога, и так пока не исчерпается предел в 999 непрерывных подсеансов лога.
      Чего просто не может быть, так как на этот лог не хватит дисков. А потом просто выдать исключение ПроблемаАрхитектурыДвижка.
      - так это можно сделать и сейчас - выдавать исключение ПроблемаАрхитектурыДвижка, и этого будет достаточно. 
 
  - Надо разработать и описать текстом сейчас пять основных процессов:
    - Добавление записи о событии в лог. 
    - Инициализация движка и лога
    - Закрытие движка и лога
 
 - Нужно сделать класс КоллекцияФайловЛога - список с сортировкой по номеру файла, а не по алфавиту.
   Так как по алфавиту числа сортируются неправильно, а в коллекции нужна правильная последовательность.
   Предикат для сортировки можно поместить в класс ФайлЛогаСолюшена.
  - можно не делать отдельный класс, а впихать его список и функции в СеансЛога. 
     Но так пока неправильно - я не знаю, что от него потребуется. 
     
        
            







      
       
              