—ценарий добавлени€ сообщени€ лога - завершен

1. ¬ызываетс€ функци€ public void LogManager.AddGeneralMessage(LogMessage msg)
1.1 ќна вызывает функцию —еансЋога.AddMessage(msg) из объекта сеанса лога LogManager.m_Session
1.1.1 ƒл€ сообщени€ создаетс€ команда AddLogMessage и записываетс€ в очередь команд —еансЋога.m_joblist

1.2 сбрасываетс€ счетчик таймаута вызовом LogManager.resetTimeCounter()

ƒалее команда и экземпл€р сообщени€ хран€тс€ в очереди команд —еансЋога.m_joblist,
пока дл€ них не подойдет очередь исполнени€ потоком-исполнителем.

ѕоток-исполнитель работает в функции protected void —еансЋога.ThreadWork()
ѕока не установлен флаг —еансЋога.m_Stop.
1. ‘ункци€ —еансЋога.m_joblist.WaitCommand() выбирает новую команду из очереди команд.
≈сли команд в списке нет, поток-исполнитель спит на семафоре.
2.  оманда сортируетс€ по коду команды CommandMessageCode.
≈сли код = AddLogMessage, то поток-исполнитель вызывает функцию —еансЋога._addLogMessage(cmd.Argument);
2.1 ‘ункци€ private void —еансЋога._addLogMessage(object p) выполн€ет разделение сообщений лога согласно их LogMessageCode.

- в файл лога неопознанных команд записываютс€ только сообщени€ с кодом ¬вод онсолиЌеизвестна€ оманда.
‘ункцией ‘айлЋога.ƒобавить—ообщениеЋога(msg).

- в файл лога консоли записываютс€ только сообщени€ с кодами:
¬вод онсолиЌеизвестна€ оманда
¬вод онсоли–аспознанна€ оманда
¬вод онсолиƒиалог
¬ывод онсоли
Ќачало—еанса
«авершение—еанса
(перечень команд может быть измене в процессе разработки проекта) 
‘ункцией ‘айлЋога.ƒобавить—ообщениеЋога(msg).

- в файл лога общего записываютс€ все сообщени€ лога.
‘ункцией —еансЋога._addMessage(msg)
2.1.1 ‘ункци€ internal void —еансЋога._addMessage(LogMessage msg) добавл€ет сообщени€ в файл общего лога.
Ёти файлов может быть создано несколько за сеанс, их размер ограничен значением OperatorSettings.ѕредел–азмера‘айлаЋога
а количество ограничено значением OperatorSettings.ѕредел оличества‘айловЋога¬—еансе
‘айл лога консоли и файл нераспознанных команд не ограничиваютс€ в размере.
‘айл нераспознанных команд один на все сеансы лога и хранитс€ в каталоге лога а не в каталоге сеанса лога.
2.1.1.1 провер€етс€ размер текущео файла лога вызовом функции ‘айлЋога.ѕолучитьѕозицию«аписи¬ онец‘айла()
Ёто сложно, так как файл лога может быть закрыт по таймауту.
2.1.1.2 если размер текущего файла более чем лимит OperatorSettings.ѕредел–азмера‘айлаЋога, то:
2.1.1.2.1 текущий файл лога закрываетс€ функцией —еансЋога.«акрыть“екущий‘айлЋога()
котора€ сейчас пока ничего не делает - недоделана. ќна должна вывести в файл лога сообщение о продолжении сеанса и закрыть файл лога.
2.1.1.2.2 генерируетс€ новый номер файла функцией —еансЋога.getЌовыйЌомер‘айлаЋога().
ќна инкрементирует переменную-счетчик —еансЋога.m_—четчикЌомер‘айлаЋога.
2.1.1.2.3 если новый номер файла лога больше чем предел OperatorSettings.ѕредел оличества‘айловЋога¬—еансе,
выбрасываетс€ исключение EngineArchitectureException("ѕревышен предел числа файлов лога в сеансе")
2.1.1.2.4 проверить размер свободного места на диске.
Ёто надо дл€ того чтобы автоматически чистить логи ќператора, когда они займут весь диск.
Ќо это неправильно - надо установить лимит на размер логов ќператора, и держать их в этом размере.
»наче диск компьюера все врем€ будет переполнен - пользователю неудобно это.
“ут еще много работы.
Ќо пока € не знаю, какой размер лога нужен дл€ суточной работы ќператора.
Ёту проверку и чисткулога выполн€ет функци€ —еансЋога.ќсвободитьћестоƒл€Ќового‘айлаЋога(...)
≈е код пока вызывает вопросы и нуждаетс€ в проверке и оптимизации.
                //1.4 проверить размер свободного места на диске.
                //1.4.1 если размер свободного места менее предельного размера файла лога, то:
                //1.4.1.1 если есть более старые каталоги сеансов лога, то:
                //1.4.1.1.1 удалить самый старый каталог сеанса лога.
                //1.4.1.1.2 перейти к пункту 1.4.1
                //1.4.2 если размер свободного места менее предельного размера файла лога, и нет более старых сеансов лога, 
                //то выдать исключение ќ исчерпании свободного места дл€ файлов лога, и завершить работу программы. 
≈сли функци€ возвращает false, выбрасываетс€ исключение EngineArchitectureException("Ќедостаточно места дл€ файлов лога")
Ёто значит, что выделить свободное место не удалось.
≈сли же функци€ возвращает true, то:
2.1.1.2.5 вызываем —еансЋога.—оздатьЌовый‘айлЋога(новыйЌомер‘айлаЋога)
2.1.1.2.5.1 —оздаем им€ нового файла вызовом ‘айлЋога.—оздать»м€‘айла(..)
2.1.1.2.5.2 создаем файл дл€ записи вызовом ‘айлЋога.Create(m_ѕутьѕапка—еансаЋога, filename)
2.1.1.2.5.3 записываем номер файла лога в объект файла лога. ’от€ он не требуес€ тут, но вдруг пригодитс€? 
2.1.1.2.5.4 записываем этот файл текущим в —еансЋога.m_“екущий‘айлќбщегоЋога.
2.1.1.2.5.5 открываем файл дл€ записи. ’от€ это делать не об€зательно, 
так как функци€ добавлени€ записи в файл должна открыть файл, если он закрыт.
2.1.1.2.5.6 вписываем сообщение о продолжении сеанса лога с кодом LogMessageCode.ѕродолжение—еанса и названием сеанса лога
2.1.1.2.6 вписываем первопричинное сообщение лога функцией —еансЋога.m_“екущий‘айлќбщегоЋога.ƒобавить—ообщениеЋога(msg).
конец.


