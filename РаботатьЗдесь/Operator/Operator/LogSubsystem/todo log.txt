Проект: Сборка и тест подсистемы лога Оператор

05 августа 2018
+ добавлены файлы кода в подсистему LogSubsystem - целиком из проекта Оператор.
  Их надо переделывать на новую архитектуру.
+ добавил код работы с движком в главную форму - почти весь, можно тестировать.
  - но сам движок лога не готов, пока тестить нечего.
+ Добавить импортируемые файлы из остальных источников
  - оставил пока на месте, потом выборочно добавлю или создам новые и наполню их кусками копипасты.
+ Обновить енум кодов сообщений лога - сейчас он не соответствует новым решениям.
+ Разобраться с функциями менеджера лога LogController - там много лишних функций входя сообщений.
  Сообщению нужно правильно присвоить класс а потом автоматически обработать его по классу.
  Поэтому нужна только одна функция ввода сообщения. Остальные убрать.
+ добавить классы очереди сообщений лога и потока обработки.
  Это сложно. Лучше бы сначала построить модель всей архитектуры лога, с диаграммами классов и событий.
  А потом уже пересобрать классы по этой модели. 
  Потом наполнить их кодом. Много лишней работы, зато потом есть графическая документация по подсистеме лога.
  Из нее проще понять и структуру, и работу лога. 
  - нет UML-диаграммера с генерацией кода. Без него это все нудно и долго будет. 
+ Роли классов:
  - LogController - менеджер лога. Представляет весь лог. 
    Принимает объект OperatorSettings при инициализации.
    Содержит входы для сообщений лога и событий таймера переполнения
    Содержит выходы для сообщений о событиях лога.
    Содержит объект текущего сеанса лога. 
  - СеансЛога - обслуживает КаталогСеансаЛога.
    Содержит функции для управления файловой системой лога внутри сеанса лога.  
  - OperatorSettings - настройки подсистемы лога и остальных подсистем.
  - ИдентификаторСеансаДвижка - представляет идентификатор сеанса,  имя папки сеанса, 
     используется в имени файла сеанса. 
  - ФайлЛога - представляет файл лога как файл сеанса лога и для записи в ХМЛ.
  - JobList - класс представляет очередь команд, которые посылаются потоку.
    Сам поток работает в объекте СеансЛога или LogController - надо определиться. 
    - название неудачное - надо вроде Очередь команд     
  - CommandMessage - представляет команду потоку лога.
    - название неудачное - надо вроде Команда лога
  - другие мелкие классы.  

Как использовать материалы, классы:
- СеансЛога - обслуживает КаталогСеансаЛога
- ФайлЛогаСолюшена - расширить им уже существующий класс записи в ХМЛ.
- МенеджерЛога - выборочно некоторые поля и функции взять в существующий класс Оператора.
- ИдентификаторСеансаДвижка - взять почти целиком без переработки
- НастройкиСолюшена - внести востребованные поля в НастройкиОператора. 
- функции инициализации солюшена из Движок.
- LogMessageChannelEventArgs импортировать полностью
- Utilities функции импортировать или включить в мою библиотеку классов.
  - а библиотеку тогда включить в проект Оператор.
  
06 августа 2018
+ почистил код  LogController, переименовал в  LogManager.
  + доделал евент MessageAdded - не тестировал
  - как его пользователь будет получать из движка Оператора?
    И там тоже есть канал обратных событий - может, надо было его использовать для лога?
    - один из каналов можно убрать потом.
  + добавил объект СеансЛога и его вызовы из  LogManager.

    
+ класс СеансЛога
  - Содержит также поток исполнения и очередь исполнения
  - Должен также представлять папку сеанса лога и содержать список файлов сеанса лога.
    - Что-то многовато для одного класса. Но пока никак не придумается что-то лучше.
    - Нужны функции работы с папками каталогов/создания имени нового файла/контроля размеров файлов и каталогов лога.
    - можно ли сделать два класса: базовый для представления сеанса как каталога, и расширенный для механизма исполнения команд лога?
      - в конструкторе не должно быть инициализации механизма исполнения команд. Только инициализация представления сеанса как каталога.
      + решено все в одном классе сделать. Он получился большой, но все еще можно ориентироваться. 
        И он не содержит списки файлов, и не представляет папку сеанса лога.
        Поэтому не может использоваться для навигации между сеансами лога.
        Он только для записи лога предназначен.
  - разработка:  
    - заготовки функций созданы, осталось наполнить. 
    - Тут нужны диаграммы и составы классов.
    И написать для них сценарии исполнения. Это нудная работа, а мне хочется спать.  
    - требуемые сценарии:
      - Конструктор объекта
      - Закрыть файлы лога по таймауту
      - Начать сеанс лога
      - Завершить сеанс лога
      - Добавить сообщение в лог
      
07 августа 2018
+ добавил старый код для классов СеансЛога и ФайлЛога.
  + код надо переделывать согласно сценариям работы системы.
  - сначала надо написать эти сценарии работы системы
  + код содержит лишние поля - их можно хранить прямо в объекте настроек Оператора, а не  кешировать тут.
    Хотя лучше кешировать - вдруг настройки изменятся прямо в ходе работы движка.
  + ФайлЛога надо свести с XmlWriter классом, но только после того,  как определится требуемый набор его функций.
    А то лишней путаницы будет много.  
- нужно добавить еще класс АктивныйСеансЛога, производный от СеансЛога, и в нем реализовать команды и поток исполнения.
  - СеансЛога обслуживает только файловую часть сеанса лога. 
    Это разгрузит класс от лишнего функционала.
    - не уверен, что там есть что обслуживать - ведь всю эту работу должен делать поток лога.
      Поток движка только запускает и закрывает подсистему лога. Остальное делает поток лога.
      Тут надо составить сценарий, что и как делается в подсистеме.
      По нему и писать код дальше.
  + решено все свести в один класс СеансЛога.
    - уже добавил в него все функции из старых классов. Теперь надо все переделать, свести воедино.    
- свести все евенты в один канал сообщений лога
  - евент из JobList подключить через обработчик
  - остальные если есть - убрать и завести через вызов функции LogManager. 
- отработать все ТОДО из солюшена    
  + 10 августа 2018: остались только тодо отладки контроля размеров файлов
    Их тестировать не получается из-за большого размера свободного места.
    И эту ветвь все равно надо переделывать на новый алгоритм.
    
08 августа 2018
+ написал код добавления сообщения лога.
  + надо написать сценарий добавления сообщения лога, тогда проще будет все отлаживать.  
  - все до функций ФайлЛога. Эти функции буду делать на посленем этапе перед тестом.
+ написал код закрытия файлов лога по таймауту   
  - все до функций ФайлЛога. Эти функции буду делать на посленем этапе перед тестом.
  - надо написать сценарий закрытия файлов лога по таймауту, тогда проще будет все отлаживать.
+ немного подправил код по рекомендациям CodeAnalysis, но не все.
  Компилируется успешно. 


09 августа 2018
+ написал запуск и закрытие лога. Все до ФайлЛога. Надо тестировать.
  - пока ФайлЛога не закончен, тестировать можно только отдельные функции.
+ тестировал и исправил все фукции класса Utilities 
+ надо выполнить тодо из кода
+ надо написать загрузку и выгрузку OperatorSettings
  + написал
  + надо тестировать весь проект целиком.
+ хотел написать функцию создания каталога Оператор, 
  Но облом - ее можно только распаковать при установке или из архива.
  Так как она содержит исполняемые файлы Оператор.
  Пришлось от этой лишней работы отказаться.
  Все создание инфраструктуры должен делать инсталлятор.
  Хотя можно и из архива распаковать, наверно. 
+ надо выполнить все надо из этого файла.
+ Добавить в LogMessage поле String Agent.
  Это поле должно содержать имя агента, выполняющего задачу.
  Для сообщений от подсистем Оператора это поле должно содержать значение System или Operator.
  Значение надо сделать константой в LogMessage или в файле настроек.
  Чтобы не переделывать все места где используется, надо завести еще один конструктор, с аргументом для имени агента.
  А остальные конструкторы, по умолчанию, переделать чтобы они в новое поле записывали дефолтовое значение.
  Так, существующий код без изменения почти, и только внутри исполнителей потребуется указывать имя агента.
  - В ХМЛ файл имя агента записывается после кода сообщения, в атрибуте: agent="Operator"  
  Вроде бы ничего больше не поменяется?
  - Это нужно потому, что при одновременной работе двух агентов 
    их лог действий будет перемешан и никак не возможно отделить их записи друг от друга
  - поле добавлено, код класса LogMessage переделан.   
+ написал код ФайлЛога. Хотя он содержит лишние поля, я надеюсь, что они пригодятся позже.
  Но при переработке кода после релиза Оператора можно их убрать.  
  
- тестирую проект, нашел проблемы:
  + void Form1.m_logman_m_MessageAdded(object sender, LogMessageAddedEventArgs e)  
  выдает исключение: листбокс не может работать с другим потоком.
    - облом. Надо буферизовать выход канала событий лога. Через список-очередь сообщений.
      Но как потом сообщения выводить этим же потоком? 
      Еще один поток - нельзя, он так же будет выдавать исключение.
      А основной поток приложения - никак не заставишь это делать.
      Надо изучить эту тему.
    + нашел решение в Интернете. Сделал, работает.
    - повысил таймаут потока-исполнителя лога до 60 секунд. 
      Было 10 секунд, отладка не получалась из-за этого.
      60 секунд должно хватить для закрытия файлов лога после команды, даже при перегруженной системе.    
  + после закрытия файлов лога сообщение об этом выводится каждую секунду.
    А должен молчать до открытия файлов лога при следующей записи а потом заново запускаться
    + добавлен флаг для однократной подачи команды закрытия файлов лога.
      После сброса счетчика таймаута флаг тоже сбрасывается.
    + проверено, работает правильно.
  + файл неопознанных команд перезаписывается каждый сеанс лога, а должен накапливаться. 
    + исправлено. При открытии файла он перезаписывал существующий файл в 
      internal static ФайлЛога ФайлЛога.Create(string folderPath, string filename)  
      Добавил проверку - если файл уже существует, создавать его не нужно.
      Получается уже другой режим открытия файла: OpenOrCreate.
      Все равно файлы лога нигде перезаписывать не нужно. 
  + лог нераспознанных команд содержит только время команды, нет даты.
    Поэтому нельзя перейти к сеансу лога, чтобы узнать причину подробнее.
    Надо сделать полный таймштамп для этого файла лога, ну и для всех файлов лога тоже.
    + сделано
  + провел нагрузочный тест: генерацию 120000 сообщений лога - нераспознанных команд.
    Они заняли менее 30Мб файла лога, но в каждом виде лога.
    Поэтому решено было снизить предельный размер файла лога до 1Мб.
    Более точный размер по умолчанию - даст только опыт эксплуатации.
    + проверил создание новых файлов общего лога - работает как ожидалось.
    + проверил баланс потоков: сначала поток-исполнитель лога тормозит, но после пары минут выравнивается.
    - все же надо бы поток-исполнитель лога сделать более приоритетным чем основной поток приложения, 
      иначе он будет завален работой при перегрузке компьютера и большом траффике на консоли и в логе соотвественно.                  
  - надо поставить обработчик глобального исключения домена приложения, показывать его в мессагобоксе.
    Чтобы отлавливать все исключения внутри потоков, насколько  возможно.      

10 августа 2018
- Примененная стратегия управления файлами лога предполагает. что все свободное место на диске отдается на файлы лога.
  Для пользователя это неприемлемо, поэтому нужно переделать систему управления файлами лога так, 
  чтобы она ограничивалась заданным размером хранилища логов.
  + Размер хранилища логов должен храниться в настройках Оператора.
    + поле и проперти и константа ПределРазмераКаталогаЛогаМб добавлены, инициализация в конструкторе сделана, проверка значения после загрузки добавлена.
  + Нужна функция быстрого подсчета размера каталога логов.
    + public static long Utilities.GetDirectorySize(string dirpath) готова, не тест.
  - Получается каждый раз перед открытием нового файла надо посчитать общий размер каталога логов, и сравнивать его с пределом.
    Если предел не достигнут, то создавать новый файл. А если достигнут - удалять старые сеансы лога.
    - свободное место на диске тоже надо учитывать - смотря чего меньше: остатка разрешенного места или свободного места.
  + функция написана, но не тестирована. См. private static bool СеансЛога.ОсвободитьМестоДляНовогоФайлаЛога2(OperatorSettings set, String sidname)  
    - могут быть проблемы, надо тестировать ее.
+ если перед засыпанием компьютера мне надо закрыть файлы лога, я могу ли это сделать без ожидания таймаута?
  + public void LogManager.CloseLogFilesTemporary() сделана.  
- написать описание подсистемы лога в файле LogSystemDescription.txt
  - да тут нужен целый план по этой работе.
- переделал OperatorSettings.ПределРазмераФайлаЛога, теперь он в мегабайтах - так проще его указывать в настройках пользователю. 
  + переделал поля и константы, код проверки настроек и места использования поля.      
  - не тестировал.

11 августа 2018
+ Надо описать подключение и использование LogManager к остальному приложению.
  Указать точки контакта и как и когда их использовать.
  Сейчас таким примером является класс формы, но в Оператор ее не будет, 
  и тогда эти знания могут потеряться в ходе переделок.
  - Этот текст надо написать выше или ниже класса менеджера в самом файле класса.
    Вверху надо написать памятку, что пример использования расположен в конце файла.
    Сами примеры кода взять из класса формы сейчас.
  + сделано: весь листинг класса формы привел - он как раз подходит - и краткий и реалистичный.    
- еще, есть проблема с файлом нераспознанных команд: Он растет постоянно, хотя и медленно.
	Если про него не вспоминать, он весь лимит размера лога займет.
	Но тут в подсистеме лога с этим ничего сделать нельзя. Надо пользователю напоминать 
	о необходимости переработать файл лога нераспознанных команд, когда он станет слишком большим.
	Для этого надо в менеджере лога приделать функцию получения свойств этого файла (Размера и пути к файлу).
	Сам Оператор периодически должен проверять это и сообщать пользователю о необходимости:
	А) переработать файл на новые/частые команды
	Б) отправить его разработчику (мне) для переработки
	В) удалить файл.   
	- но этот файл уже открыт в менеджере лога, и его сложно будет еще раз открыть для просмотра свойств и содежимого в Операторе.
	  Об этом надо думать отдельно.       
+ надо тестировать подсистему лога целиком, особенно механизм контроля размера каталога лога.
  См. private static bool СеансЛога.ОсвободитьМестоДляНовогоФайлаЛога2(OperatorSettings set, String sidname)
  Это будет долго, я думаю. Надо разработать процесс тестирования.
  + проверено в общем, ошибки исправлены, работоспособно.
  + в процессе работы возможно небольшое превышение установленного размера каталога лога из-за того, 
     что размеры файлов лога консоли и нераспознанных команд нельзя учесть правильно.
  - сортировка имен папок сеансов лога не была полностью протестирована, поэтому в процессе эксплуатации 
     все же могут возникнуть проблемы. Но сейчас их выявить не получается - нужно много подобного материала.
     Поэтому выявление остаточных ошибок будем проводить в процессе опытной эксплауатации Оператора.
     Если заметим их. 
     
-  можно считать, что подсистема лога готова к переносу в Оператор. 	  