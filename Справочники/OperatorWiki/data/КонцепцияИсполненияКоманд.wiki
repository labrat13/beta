++ Концепция Исполнения Команд
[template: ШаблонСтраницыРазделаКонцепции]
Состояние: [В РАЗРАБОТКЕ]
* Тут должно быть только исполнение команд. Состав команды и перечни команд, места - надо перенести в РазделДиалогСПользователем или в новый раздел концепции, посвященный теории собственно команд и мест РИ для Оператора.
* Задача: поставить вопросы по концепции - тут много пробелов в концепции, вопросы должны их обозначить.

+++Ссылки раздела
* ГлоссарийОператор
* ПланСтруктурыРазделаИсполнениеКоманд - план набросан, теперь его скопировать на страницу сборки и наполнить материалами. Затем дополнить материалами из других разделов вики. Перерабатывать материалы во всей концепции будем позже, так как это будет долго - их много.
    * Из-за очень большого объема материалов лучше план разбить на раздельные страницы-сборки. Это работа на несколько недель, на самом деле. 

+++Содержание раздела



++Материалы

+++Формы глагола в команде
[Команда]а обычно должна начинаться с глагола. Он должен быть первым словом в [Команда]е.
 * Глагол в первичной форме, Например, Открыть, удобен для написания скриптов, состоящих из множества [Команда].
 * Глагол в личной повелительной форме, Например, Открой, удобен для собственно пользователя. Хотя и им тоже можно писать скрипты, но они тогда выглядят не абстрактно, как обычно общепринято.
    * Но все же можно и писать скрипты - инструкции, и вводить так более естественно. Это надо привыкнуть, а мне сейчас не очевидно.
* Поскольку [Команда]а может использовать разные формы этого глагола, то нужно их обрабатывать.
    * На все глаголы, используемые в [Команда]ах, надо иметь и первичную и повелительную формы.
    * Надо подменять первичную форму глагола на повелительную, если [Команда]а не была распознана.
* Чтобы знать соответствие между формами глагола, вносим формы глаголов в словарь парами.
    * Поскольку словаря полного нет у меня сейчас, то вносим формы глаголов, запрашиваемые при создании [Команда]ы.  
* [Алгоритм] поиска обработчика [Команда]ы такой:
    1 принимаем текст [Команда]ы
    2 сбрасываем флаг замены глагола
    3 прокручиваем цепочку поиска обработчика [Команда]ы 
    4 Если [Команда]а не была распознана в общем порядке, то:
        5 Если флаг замены глагола сброшен и первое слово из текста [Команда]ы имеется в словаре форм глаголов, то 
            6 заменяем его на другую форму этого же глагола из словаря
            7 устанавливаем флаг замены глагола.
            8 переходим к шагу 3 - снова пробуем распознать [Команда]у в обычном порядке.
    * Иначе - сообщаем что [Команда]а не распознана, конец. 
    * 


+++Исполнение команд в общем плане
Теоретически, каждая [Процедура]а реализует некий СценарийИспользования.
Как в UML, этот сценарий должен быть спроектирован и назван.
В рамках этого сценария, есть некая конечная цель - конечное состояние системы, которое должно быть достигнуто в ходе выполнения сценария.
И есть [Алгоритм], способ, которым достигается результат.

В настоящее время рассматриваются сценарии очень простые, поверхностные, вроде Открыть плеер.

Однако можно попробовать и более сложные сценарии собственно работы над [Задача]ами.
Проблема тут в том, что [Задача]и у меня в основном одноразовые. 
Их я могу выполнять вручную. Это проще, чем писать [Алгоритм]ы на каждый чих.
А автоматизировать нужно повторяющиеся [Задача]и. 

И еще одна проблема - мне нужно сохранять эти настройки автоматизации, чтобы потом восстанавливать их автоматически, а не вручную, после переустановки операционной системы.

Итак, после собственно первичного внедрения этого прототипа РИ, нужно задуматься о применении его в моих проектах на повторяющихся [Задача]ах. Для этих [Задача] придется написать программы-исполнители и добавить их в прототип РИ.

Еще можно подумать о том чтобы более глубоко разбирать семантику предложений. Например, не просто тупо искать совпадение по шаблону, а понимать простое предложение: выделять действие и его сущности-аргументы, и признаки действия или сущности. 
Например: Создай в моей музыке новую папку и добавь в нее все музыкальные файлы из флешки.  
Механизм должен собрать из этого текста [Алгоритм], проверить его на непротиворечивость, подставить параметры по умолчанию, смоделировать исполнение и затем исполнить.
Но этот механизм нельзя реализовать без проектов Тапп и Вордс.

* Честно говоря, программой пользоваться не так уж удобно - надо помнить все эти [Место]а и названия [Процедура]. Хотя они и приближены к обычной речи, но все же их надо помнить или наугад набирать. Просто их должно быть меньше. У меня сейчас много проектов и [Задача] по ним, вот я и живо представляю себе весь этот объем названий сущностей, которые надо помнить.
* Тут можно еще предложить по любому старому проекту вызвать лог работ (процедур), чтобы просмотреть его и понять, на чем проект остановился. Винда сейчас такое не позволяет делать. Да и этот прототип РИ тоже не позволит, так как нет поддержки КонтекстЗадачи, поэтому нельзя отобрать события по этому контексту.
* Надо все же сделать это меню [Место] и  [Процедура] - оценить, насколько это мне поможет ориентироваться в [Место]ах.
* Для голосового управления этот РИ отлично подходит. Можно прямо сейчас даже попытаться навесить хотя бы говорение. Хотя ввод все равно с клавиатуры будет. Не, лучше музыку слушать. 


+++Определение соответствия команды и операции
Это можно сделать сейчас на простом regex.  

^копировать (?<file>.+) в (?<folder>.+)$

Пример: копировать С:\file\кошку17 в резиновую кошку около собачьей будки

Надо загнать это в код и убедиться, что:
-входная фраза определяется как подходящая. Regex.isMatch()
-аргументы file и folder содержат правильные значения.
Сделано, проверено. Код в проекте.

Сначала надо убедиться, что [Команда]а соответствует предлагаемой операции.
Потом надо выделить из [Команда]ы аргументы.
Это будет или 2 разных выражения, или одно. 

Установлено, что [Алгоритм] выделяет слова неправильно, если паттерн неоднозначен:  
Пример: копировать С:\file\кошку17 в резиновую кошку в собачьей будке
В данном случае, последняя " в " была посчитана как разделитель вместо первой.
Поэтому тут нужен более сложный, семантический анализ предложения, чтобы выделить объекты по шаблону.
И тогда надо как-то выявлять это недопонимание и запрашивать пользователя, чтобы он переформулировал [Команда]у.
Как выявлять такие [Команда]ы? 
* В них часть паттерна повторяется, это и делает разбор выражения ошибочным. Надо проверять [Команда]у и паттерн на такие ситуации. Но это простой случай. Паттерн может быть более сложным. Тут надо думать потом, по месту.
 
 regex не может точно определить аргументы. И может вызвать не те [Процедура]ы.
 Поэтому надо еще *очередность проверки выражений*. Что-то раньше, что-то позже.

+++Операции со списками
Нужны операции с элементами списка, полученного в результате выполнения некоторой [Команда]ы. Например, список файлов в каталоге.
И нужны сами списки как Сущности внутри [Алгоритм]ов скриптов и как аргументы [Команда].



++ Контекст Задачи
+++Наблюдение РИ
* эти все [Процедура]ы надо выносить в скрипты, и чтобы их можно было запускать рекурсивно. Но и тут удобно то что используются разные словоформы для [Место]. А вот проверять семантику операции - это и есть интеллект. И еще КонтекстЗадачи. Пока у системы нет наблюдения за происходящим, это не получится достаточно полезная система. В нее надо передавать действия пользователя - например, открытие папки или запуск приложения. Хотя проблема в том, что приложение не знает, работает ли пользователь с программой или ушел, или просто его глючит.

+++Контекст для Оператора
Преимущества системы с контекстом в том, что контекст процесса дополняется остатиченным контекстом класса подобных процессов. Предоставляя процессу опыт и методики, выборы и решения предыдущих процессов. Сторонние объекты, которые могут возникнуть в процессе работы. Выборы и их результаты. Процесс в этом виде есть проход по графу вариантов развития событий. И это можно в дальнейшем использовать. Хотя сейчас просто из этого графа выбирается один путь и по нему строится [Алгоритм] процесса. Но граф-контекст был бы супер[Алгоритм]ом - универсальным [Алгоритм]ом для всех процессов этого класса процессов.

Это уже была бы сравнимая с человеческой система опыта. 

+++Идея Контекст как сессия задачи
13.03.2017 14:07:36
Контекст подобен транзакции в логе Тапп. 
Контекст можно представить таким деревом вложенных процессов. Несколько одновременно начатых [Задача], некоторые вложены в более ранние [Задача]и.
И каждая [Задача]а представлена собственным объектом-итемом в этом дереве процессов-[Задача].
У каждой [Задача]и есть собственный уникальный идентификатор [Задача]и.
В таком виде эти [Задача]и проще отслеживать и определять, к какой [Задача]е относится текущая [Команда]а пользователя.
[Алгоритм] [Задача]и получается интерпретируемым набором простых [Команда], и пользователь может даже вперемешку несколько [Задача] отрабатывать в одно время. Хотя, возможно, ему придется указывать, к какой текущей [Задача]е относится его сообщение.
Это применительно к исполнению [Задача] как в Х3, через триггеры. И это относится к диалогам в [Алгоритм]ах [Команда]. И к вложенным [Команда]ам в [Алгоритм]ах [Команда].
И хорошо бы иметь лог таких действий, чтобы вести наблюдение и автоматически выявлять паттерны [Алгоритм]ов в работе пользователя.

+++Контекст
Оператору нужен контекст работы.
-Контекст можно фиксировать в логе. Хотя это не совсем то. Контекст лучше вести отдельной от лога последовательностью записей. А лог будет дополнять его при необходимости.
-Контекст должен иметь начало и конец. И еще он приостанавливается и возобновляется. 
Контекст это некий рабочий процесс. Все что происходит в рамках этого процесса, должно сохраняться в контексте.
Обычно пользователь понимает, когда он начинает или заканчивает или возобновляет или приостанавливает процесс и соответственно, контекст.
Тут Оператор - это наблюдатель, которому надо эти состояния специально описывать, так как он сам ничего не понимает.
-Контекст будет хранить и выполненные операции и результаты.
Результаты можно хранить как Сущности - [Место], локальные для процесса.
-Надо больше работать на тему контекста! 

+++контекст задачи
После отладки основных механизмов можно добавить в систему контексты.
Например, я запустил плеер,   и в системе хранится контекст задачи - плеера. И пока я не закрыл плеер или не скомандовал прекратить воспроизведение, контекст действителен и [Команда]ы интерпретируются с его учетом.
Может быть одновременно несколько действующих контекстов.

Например, [Команда]ы Тише или Громче при контексте плеера изменяют громкость. А без контекста плеера они выдают сообщение о неправильном использовании.

Для РИ нужно не только исполнять отдельные [Команда]ы, но и хранить их результаты. Для использования в дальнейших работах. Как это можно сделать?
1) помещать их в Тапп
2) хранить их в файлах, которые затем регистрировать как локальные временные [Место] в рамках [Задача]и.


Тапп можно использовать для хранения контекста [Задача]и и переменных общего процесса. Один контейнер Тапп на все [Задача]и сессии пользователя.

Хорошо бы использовать Тапп для хранения Сущностей-Мест и Методов-Процедур.
- но [Место] часто имеет несколько классов по разным классификациям. Как в моей Тапп описать несколько надклассов для [Место]а? Если в поле ТипЯчейки можно поместить только один класс?
  - Можно в это поле вписать пустой идентификатор, а надклассы указывать связями определенного типа с этими надклассами.


Так, могут быть [Место]а, существующие только в контексте некоторой [Задача]и. Вроде локальных переменных в [Алгоритм]е.

[Задача]а может быть прервана и продолжена после перерыва или отменена.
[Задача]а может быть просто отменена, причем ее промежуточные результаты в одном случае нужно сохранить для последующего использования, а в другом - можно удалить вместе с [Задача]ей. Эти промежуточные результаты могут быть настолько большими по размеру, что хранить их продолжительное время, подобно как в архиве, окажется нецелесообразно.
[Задача]а может быть прервана на дительное время, и убрана в архив, чтобы потом достать ее и продолжить почти с прерванного места [Алгоритм]а.

То есть, я пытаюсь реализовать в РИ процессы, чтобы выполнять с его помощью свои проекты-[Задача]и-работы.


Когда я работаю над некоторой [Задача]ей, я работаю в контексте этой [Задача]и. А потом я намерен из него выйти, кратковременно или продолжительно. Как это описать для РИ Оператора? Надо ему дать понять, что я остановил эту [Задача]у и переключился на другую. И теперь мои [Команда]ы должны уже трактоваться в контексте этой другой [Задача]и. Как оформить это в слова? Как это происходит в реальности?

Есть операции, правильные только в контексте [Задача]и, то есть, локальные для [Задача]и. Как приватные методы класса. И их названия для разных [Задача] часто одинаковы, а семантика и [Алгоритм] часто различаются. То есть, нужно ввести в РИ контексты, и [Задача]и и операции в этих контекстах как сущности, [Команда]ы должны интерпретироваться в зависимости от текущего контекста.
Это похоже на класс, где функции с общеупотребительными названиями переопределяются для соответствия семантике работы с объектами этого класса.


Контексты [Задача] помогут автоматизировать работу по повторяющимся [Задача]ам в версии с наблюдением. Там можно просто сопоставлять истории выполнения [Задача] и выявлять сходные участки, параметры итд, и потом автоматически их подставлять в общий шаблон выполнения этой [Задача]и.

+++Новая Контекст задачи
24.03.2017 15:18:08
КонтекстЗадачи в диалоге с пользователем можно различать сообщением пользователю от [Задача]и. По [Задача]е ИдентификаторЗадачи: \n Сообщение пользователю.
* Но тогда консоль должна ждать ответа пользователя, чтобы сообщения от других [Задача] не вторгались в Диалог [Задача]и и не путали пользователя. Это можно назвать Захват Консоли [Задача]ей.
* Собственно КонтекстЗадачи должен содержать: 
    * ТекстКоманды, который ввел Пользователь, как описание [Команда]ы для пользователя. 
    * ИдентификаторЗадачи
* Если [Задача]а всего одна в настоящий момент, то ее КонтекстЗадачи может захватить Консоль пользователя.
* Если [Задача] несколько, то лишь одна из них может Захватить Консоль. Когда одна [Задача]а Освобождает консоль, другая [Задача]а может захватить Консоль.
* Нужна [Команда]а Посмотреть список [Задача]. Она выводит список [Задача] по их КонтекстЗадачи. Эти [Задача]и должны храниться в некотором СписокКонтекстовЗадач в Движке.
* Одна из [Задача] является обычно текущей - она захватила Консоль Пользователя и получает Ввод пользователя.
* Пользователь может переключиться на другую [Задача]у, но надо указать ее ИдентификаторЗадачи.
    * Это должен быть короткий, кратковременно запоминающийся идентификатор для [Задача]и. Где его взять?
    * ИдентификаторЗадачи хранить, конечно, в объекте КонтекстЗадачи.
    * Как пользователь сможет запомнить ИдентификаторЗадачи?
    * Тут проблема - этот идентификатор должен быть удобным, не повторяющимся, не запоминающимся надолго?
        * Можно ввести классы [Задача] (или [Процедура]?). И по ним называть. Например, Копирование-1, Архивирование-2, ...
        * Можно по первому слову [Команда]ы - оно должно же быть глаголом. Искать-1, итд. Числа присваивать по порядку одинаковых названий в СписокКонтекстовЗадач.
* [Команда]а переключения на [Задача]у: Для [Задача]и ИдентификаторЗадачи:
* [Команда]а посмотреть текущую [Задача]у - просмотреть КонтекстЗадачи, которая захватила Консоль. Нужно описание [Задача]и и историю сообщений.
* Пользователь переключается между [Задача]ами с помощью [Команда]ы. То есть, надо эти действия организовать в [Команда]ы, использующие АПИ Движка для работы с [Задача]ами.
* Для анализа лога надо и сообщения в лог группировать по этим КонтекстЗадачи, чтобы все сообщения лога по [Задача]е можно было свести в одну последовательность. Реально же они будут разбросаны по логу вперемешку с сообщениями других [Задача].
* Тогда вывод сообщений от [Задача]и в Консоль тоже надо регулировать. Если [Задача]а не может в любой момент запросить пользователя, то нужна некая очередь запросов на каждый КонтекстЗадачи. Запрос [Задача]и должен ожидать завершения текущего диалога другой [Задача]и - Освобождения Консоли.
    * А как тогда иметь сообщения, что [Задача]а Х завершена, пока пользователь работает с [Задача]ей У?
    * Не надо прерывать диалог [Задача]и Х сообщением от [Задача]и У. А то придумываешь тут регекс, а тебе нате вдруг - Сжатие завершено. И не вспомнить, какое там сжатие, и не узнать - диалог же нельзя прерывать. Поэтому сообщение от [Задача]и У пусть выводится, когда нет текущей [Задача]и, Консоль не Захвачена [Задача]ей.
* Нельзя выводить сообщения другой [Задача]и, когда идет ДиалогЗадачи. То есть, пока [Задача]а ожидает ввод пользователя.
* Когда [Задача]а Освободила Консоль, любая другая [Задача]а,отправив свое сообщение, может захватить Консоль себе, и, возможно, в СписокКонтекстовЗадач есть такие [Задача]и с сообщениями. Тогда они по очереди захватят Консоль.
* Но тогда [Задача]а должна Захватывать Консоль лишь на время Диалога, а не до своего завершения, как сейчас думается. Это надо как-то обозначать - начало и конец такого Диалога. Захватить Консоль, Освободить Консоль, Внимание, Фокус ввода?
* Всякие эти концепции уже есть в ПО - надо их найти и применить.
* Но процесс этот сложный - надо построить диаграммы на эту синхронизацию потоков и контекстов [Задача].
* Отложено на ТретийПрототипКонсолиРИ - Это отложить на следующий Прототип Оператора. Сейчас слишком много проблем с текущей архитектурой. Она уже довольно сложная.
* Значит, чтобы начать диалог с пользователем, [Задача]а должна вызвать функцию Захватить Консоль (Привлечь Внимание, Начать Диалог). Если консоль была свободна, Консоль Захватывается, эта функция сразу возвращает управление, и [Задача]а начинает свой Диалог. Если же Консоль уже захвачена другой [Задача]ей, то наша [Задача]а ждет (поток спит, ожидая события), пока Консоль освободится. 
* Когда ДиалогЗадачи закончен, [Задача]а вызывает функцию Закончить Диалог и Консоль освобождается. Когда [Задача]а отправляет сообщение в захваченную Консоль, та или выводит сообщение, или ...
* Пользователь может переключиться на другую [Задача]у. То есть, он принудительно отбирает Консоль у [Задача]и. Тогда [Задача]а, ранее захватившая Консоль, переводится в очередь, ожидая, когда пользователь к ней вернется, или Консоль еще как-либо освободится.
    * Но еще надо сохранить флаг что эта [Задача]а уже ранее захватила Консоль, теперь она не сможет подать сигнал о захвате Консоли - этот захват надо будет восстановить.  
* Пользователь не может перейти от [Задача]и в никуда - он должен перейти к другой [Задача]е. Или к [Задача]е Запуска [Задача]и. Таким образом, [Задача]а рано или поздно сможет продолжить Диалог.
* Так может оказаться, что компьютер выключается до завершения некоторых [Задача]. Это надо обработать, или вообще не выключать компьютер, или отложить [Задача]и на болеепозднее время - на следующий запуск компьютера. Это еще один список [Задача] - СписокНезавершенныхЗадач.
* А если диалоги нужны во вложенных [Процедура]ах - как их тогда ИдентификаторПроцедуры представлять пользователю?
    * Их точно надо отличать от [Процедура] верхнего уровня, иначе пользователь просто заблудится в этих [Процедура]ах и их диалогах.
    * Можно указыватьтолько первый и последний уровень вложенности [Процедура]ы.
    * Диалоги, конечно, надо показывать пользователю.    
    * Как показывать, что они вложенные и в какую [Задача]у?
    * Это тогда будет такая система ответов на возникающие вопросы. Прыгая между [Задача]ами, Пользователь ведет все их одновременно.
* Консоль тогда надо в отдельный класс превратить. Вернее, это будет АдаптерКонсоли. Так как это не сама форма чата, а ее приспособление к системе.   


++ Тема Исполнение Команд

+++Тут надо сделать промежуточный слой-конвертор
Надо: Покажи мне музыку
Есть: Открыть МояМузыка => Открыть %1 => ShellExecute(C:\Моя музыка);
Конвертер должен будет запомнить соответствие между командой свободного текста и уже существующей жесткой командой.
Причем команд свободного текста будет много на одну жесткую команду.
Их надо просто запомнить. Для каждой свободной команды должно быть только одно соответствие к жесткой команде.
Это соответствие устанавливает пользователь, когда свободная команда не может быть приведена к жесткой команде, Оператор должен его запросить, установить соответствие и запомнить его.
Это сделает Оператор более свободным, но его придется долго обучать - настраивать.

+++Исполнение команды - набросок
При исполнении команды еще нужна проверка правильности.
Способ А - Предварительное уведомление пользователя
>Играть хиты
<Команда Играть %плейлист - Запуск плеера для плейлиста. Запустить? Да/Нет
>Да
...исполнение команды

Способ Б - Уведомление после попытки исполнения
>Играть хиты
...исполнение команды
>Неправильно!
<Выберите соответствующую команду:
< 1. Играть %плейлист - Запуск плеера для плейлиста.
>1
<Соответствие запомнено.
...исполнение команды

В обычном общении в жизни сообщение об ошибке в выборе исполняемой команды производится после начала исполнения команды, в начале исполнения, поскольку пользователь может наблюдать процесс исполнения задания.
В компьютере процесс не виден пользователю.
Тут следует рассматривать подобные ситуации, когда пользователь не видит исполнителя, и держит с ним устную связь через чат или телефон. Тогда пользователь обнаруживает несоответствие ожиданиям уже в процессе выполнения команды (Не та музыка играет) или в результатах исполнения команды (Я просил табуретку, а ты принес стул).

Еще, нужна клавиша паузы - останова исполнения команды, и клавиша прерывания-отмены исполнения команды.
Так как с клавиатуры слишком долго набирать команду отмены текстом.
- Эти клавиши работают только при исполнении команды, пока она в консоли Оператора работает? 
- Как откатить исполнение команды, если она отменена клавишей отмены?
- Надо ли это делать, откат исполнения команды?
- Можно ли обойтись бекапом и восстановлением из бекапа? 

+++Потоки исполнения команд
* Испльзуется в ТемаАгентИсполнитель.
Для архивов хорошо бы, чтобы Оператор мог сообщить пользователю о завершении сжатия или распаковки большого объема. Ну и вообще, сообщить о завершении длительного процесса. И сам этот процесс не должен делать Оператор недоступным, ожидающим завершения процесса. 
Для этого Оператор должен дождаться завершения процесса архиватора и вывести сообщение о результате пользователю. Для этого надо каждый запуск [Процедура]ы выделять в отдельный поток, чтобы он мог следить за процессом, одижать его завершения и производить пост-обработку.
    * А как сообщения из такого временного потока отправлять в Логи в ГУЙ?
        * Через специальные каналы сообщений. Которые собирают сообщения в свою очередь и потом выводят в лог и на экран пользователю. 
        * Такие [Задача]и без КонтекстЗадачи плохо реализовывать. Хотя и возможно. Но вот как отменить [Команда]у Сжать архив Х, если она не синхронная? Если я уже пять таких запустил, и не знаю теперь, какая тут на экране какая? Пока можно просто диалог сжатия мышкой отменить, а то бы и вовсе никак нельзя было вмешаться через Оператор-то.
        * То есть, для каналов нужно создать Ивент и приемник сообщений отдельно для Лога и для Гуя от потоков исполнения [Процедура]. ПотокИсполненияПроцедуры будет подключаться к этим ивентам при создании  и отключаться при завершении. Поток будет оправлять сообщения в каналы Лог и Гуй. Эти сообщения должны помещаться в очередь, чьтобы не перебивать друг друга.
        * Эта инфраструктура пригодится при внедрении КонтекстЗадачи потом.
* Эта концепция предполагает создание внутри Оператора массива виртуальных исполнителей АгентИсполнитель. 
    * todo: проработать эту тему, я хочу реализовать ее в текущем релизе Оператора. См. ТемаАгентИсполнитель.
    * Каждый агент может выполнять собственное задание, команду. Или может простаивать - как виртуальный исполнитель, разумеется.    
    * Каждый АгентИсполнитель имеет собственный поток исполнения и сам выполняет свое задание.
    * Агент имеет собственное название, которое зарегистрировано как место-Сущность специального класса. Пользователь может использовать эти имена агентов для более естественного управления при речевом взаимодействии с Оператором.
    * Сообщения от агентов выводятся на консоль Оператора подобно чату с несколькими людьми. Логин агента позволяет сообщениям не перемешиваться в общем листинге. Однако, только один агент может вести диалог с пользователем в один момент времени до окончания диалога. Иначе пользователь совсем запутается в этих диалогах.
    * В Лог агенты выводят сообщения от своего имени. Также, есть системные имена агентов User, Operator, System. Они используются для обозначения источников записей лога, созданных соответственно, пользователем, оператором, и тоже оператором. Поэтому, хотя в Логе сообщения нельзя группировать по сеансам и транзакциям лога, как в Тапп, они все же сохраняют возможность разобраться, кто и что делал одновременно.
    * см также ТемаМногозадачность.
         

+++Поддержка взаимодействия приложений с Оператором
Теперь все мои программы должны поддерживать взаимодействие с Оператором.
Для этого нужно разработать интерфейс API и методику взаимодействия. Начиная с загрузки и подключения приложения к Оператору и наоборот.

Еще полезно было бы сделать в Операторе выполнение работ по списку объектов.
Однотипные работы вроде Найти все даташиты для деталей из списка.
Или Создать список деталей Инвентарь без ссылок на даташиты.
Хотя часть такой работы придется делать вручную, все же другую часть сделает Оператор. Это ускорит общий процесс.
Такую работу мог бы делать обычный скрипт, если написать хорошую функцию проверки условия. 
Хотя эта проверка и есть самое сложное в таком скрипте.
Оператор сможет сделать такую работу только после того как обзаведется собственным интеллектом, создающим [Алгоритм] по текстовому описанию [Задача]и.

Можно просто написать скрипт, но его не получится повторно использовать. И для скрипта тоже нужен доступ к АПИ каталога объектов.

+++Управление приложениями
* Приложениям можно отправлять [Команда]ы через комбинации клавиш хоткеев, но нужно иметь дескриптор окна.
* РИ можно сделать как мою экранную клавиатуру. Надо следить за запущенными приложениями и текущим окном с фокусом ввода, переключать при необходимости на другое окно и отправлять в него нажатия клавиш.
    * КакСделанаМояЭкраннаяКлавиатура.
    * Еще надо бы распознавать, какому приложению принадлежит это другое окно, и соответственно выполнять [Процедура]ы. 
* Это позволит управлять приложениями вроде блокнот и калькулятор и другими приложениями через комбинации клавиш-хоткеев.
* Например, я описываю в вики некую сущность, потом переключаюсь на Оператора и ввожу Добавить шаблон операций сущности. Оператор вставляет в текущую позицию в окне вики текст соответствующего шаблона через Ctrl+V.
* Еще можно в любом текстовом редакторе вставить в тексте маркеры вставки или замены, а потом вызвать Оператор, чтобыы он просмотрел текст, заменил эти вставки на соответствующие тексты. 
    * Например, в Блокноте: Копировать %мою музыку% в %мои документы%. Или даже todo: Добавить шаблон операций сущности.
    * Оператор делает ctrl+s; ctrl+a; ctrl+c; обрабатывает текст из буфера обмена и вставляет результат в буфер обмена; ctrl+x; 
* Но это все конечно не так надежно, как специально разработанный для Оператора текстовый редактор. В котором Оператор может делать все это более свободно и предсказуемо.
* И такое можно сделать для студии, при наборе кода. Тогда Оператор сможет дописывать за меня код. Это надо проработать. Это фишка, которая расширяет возможность использования уже существующих программ.
* То есть, Оператор должен отслеживать приложения и их окна, особенно текущее окно с фокусом ввода.
* То есть, это наблюдение за работой компьютера. Хорошо бы получать события монтирования и извлечения дисков, показа окна, запуска процесса, завершения сеанса и засыпания компьютера. Еще события секунд или минут.
* А сам Оператор тогда должен постоянно висеть в трее и показываться по глобальному хот-кею.


+++Плеер
* В общем, плеер надо искать специально, чтобы он на все подходил.
* Плейлисты не всеми востребованы. Так как их надо специально настраивать. В виндовс есть возможность всю папку аудиозаписей разом отправить в плеер для проигрывания. Вот надо эту возможность добавить в ВторойПрототипКонсолиРИ.
++++Обязанности плеера
* Плеер должен проигрывать файлы музыки и видео.
* Плеер должен проигрывать папки, содержащие файлы, как плейлисты. Эти папки оборачиваются в [Место]а.
* Плеер должен проигрывать плейлисты, которые оборачиваются в [Место]а.

++++Windows media player
* Запуск файла можно через ShellExecute или path\wmplayer.exe path\musikfile.mp3
* При экспериментах с плеером начал глючить Проводник и отключился виртуальный диск. 
+++++Запуск плейлистов.
* Плейлисты сейчас сохраняются в папке как [file:///C:/Documents and Settings/Smith John/Мои документы/Моя музыка/My Playlists/хиты.wpl]. При их активации сразу открывается плеер и начинается воспроизведение. 
* У меня пока нет плейлистов, чтобы их запуск был существенной заботой.
* Еще, есть автоматические плейлисты по рейтингам и другим обстоятельствам. Они в папке [file:///C:/Documents and Settings/All Users/Документы/Моя музыка/Sample Playlists/00121219/Plylst7.wpl] - автоматически сформированы, поэтому и имена у них незначащие и лежат они не там где удобно.
* Можно с плейлистами так же как с проектами - автоматически импортировать их как [Место]а определенного класса для пользователя. Только как получить их папку хотя бы? Пользователь это автодобавление сам запустит и папку укажет?
* [Команда]а, наверно будет: Играть %плейлист.

++++Media player classic
* Устанавливается вместе с K-Lite Codec Pack
* проигрывание папки с файлами, только в текущем каталоге, без рекурсии:
"C:\Program Files\K-Lite Codec Pack\Media Player Classic\mpc-hc.exe" c:\work\музыка  /play /close
* плейлисты от wmp не поддерживаются.
* Просмотр плейлиста неудобный - он в отдельном  мелком окне.

++++Плеер в Линуксе
* а в линуксе вообще с музыкой проблема - кодеков нет, и ее проще с инета играть, чем локально.

+++Обработка неопознанных команд
Если команда не опознана, то:
-вывести сообщение Неизвестная команда
-Записать команду в общий лог принятых команд. (Надо вести общий лог команд)
-Записать команду в список неопознанных команд, для более позднего анализа.
-предложить варианты команд как выборку из БД команд по словам из команды.
--это предполагает, что уже проведен анализ структуры команды, из нее выделены места/сущности.
--если пользователь что-то из предложенных вариантов выберет, записать это как алиас этой команды.
  Но алиас это прямая замена текста команды. Он не годится для команд с аргументами. Поэтому он должен предлагаться в списке вариантов замены команды, ане исполняться непосредственно.
--Даже если пользователь выберет из списка вариант альтернативы введенной команде, в нем придется заменить сущности. Автоматически это сделать сложно. Проще использовать его как подсказку пользователю, который должен заново ввести уже исправленную команду.
--Альтернативные команды должны выводиться с описанием их смысла. Иначе будет непонятно, какую команду надо выбрать и что она делает.

++Исполнение команд 2
Это новая попытка представить исполнение команды для новой архитектуры Оператор.
* команда может иметь процедуру-скрипт.
* Скрипт это простая последовательность текстовых команд, по одной на каждой строчке текстового файла.
* Интерпретатор скрипта пока будет простейший - просто последовательное исполнение команд одна за другой.
* Вся процедура исполняется одним АгентИсполнитель.

+++Замечания
* Интерпретатор получает или одиночную команду или скрипт. Скрипт это или нет - выясняется только после выбора процедуры для команды. А в скрипте - еще команды. Надо 2 раза запускать разбор команды: для первоначальной команды и для команд внутри скрипта.
* А если скрипт тоже содержит команды со скриптами, то и вовсе получается жуткая штука. Для команд внутри скрипта нельзя их отдавать в Движок для обработки,даже этим же Исполнителем - такая широкая рекурсия плохо кончится. Рекурсию надо крутить в очень узком кругу, не вовлекая в нее разные лишние сущности.
    * Значит, все исполнение любой команды надо отдать Интерпретатору скрипта. Он и будет крутить рекурсии в себе. А Исполнителя назначать ранее этого и более не менять до самого конца. 

+++Примерный алгоритм
* в целом, не совсем правильный. Но лучше, чем ничего. 
* todo:Надо переделать, когда будет понятна вся архитектура Оператора.
1) Консоль пользователя - ввод команды
2) Движок - выбор исполнителя.
    * если нет свободных исполнителей, сообщить об этом пользователю и прекратить обработку команды.
3) Движок - разбор команды
4) Исполнитель - поиск процедуры для команды
5) Исполнитель - исполнение процедур(ы)
*  Исполнитель - исполнение скрипта (вариант для скрипта)
6) Интерпретатор скрипта - загрузка скрипта по его файловому пути
* если скрипт не обнаружен или неправильный формат, сообщить об этом пользователю и прекратить обработку команды.
7) Интерпретатор скрипта - выборка на исполнение одной команды
8) Интерпретатор скрипта - разбор команды
9) Исполнитель - поиск процедуры для команды
* Проблема: вложеные процедуры и рекурсия!
    * Решение: Стековая модель, один Исполнитель и много экземпяров Интерпретатор скрипта. Подобно MeraMath. 
10) Исполнитель - исполнение процедуры или скрипта
11) Исполнитель - если скрипт не закончился, перейти к 7).
12) Исполнитель - вывод отчета на консоль пользователя и завершение обработки команды.
* тут пока нельзя точно сказать, что именно надо делать - надо освободить все использованные ресурсы и вывнести отчет о результатах работы.

* одинаковые пункты: 3) и 8); 4) и 9); 5 и 10) - можно было бы совместить, если использовать Интерпретатор скрипта для исполнения входной команды, даже если она не содержит скриптовой процедуры..  

++ Как заставить Оператор повторять процессы?
* todo: отложить, проработать идею, потом пригодится. Отложено на ТретийПрототипКонсолиРИ.
Оператор сможет лишь тупо повторять ранее записанный процесс. При любом отклонении весь процесс должен прекращаться или его должен доводить до конца пользователь своими командами. И при первом и при последующих исполнениях процесса должна создаваться ЛентаСобытий как средство накопления опыта Оператор.
* question: Как называется эта новая функциональность? Мне ее надо обозначать в документации.
* question: Как называется этот процесс, который должен наблюдать и воспроизводить Оператор?
* *Решение:* Отложить эту функциональность на следующую версию Оператор. 
    * Это получается очень большая и сложная система лент, итп. Без средств автоматического поддержания порядка я совсем не смогу с ней работать. Нужен опыт работы с Оператор, чтобы спроектировать всю эту возможность.
    * Вообще, Руководство пользователя Оператор уже должно получиться размером с библию. Если я еще и такие штуки в нее сразу буду вставлять, пользователь не осилит Оператор. Я сам рискую не осилить этот проект, если буду включать в него эти инновационные идеи.
    * Но саму идею надо проработать, насколько это возможно - потом проще будет ее внедрить.  
* Надо обозначить явно Начало процесса - командой Начать процесс <Имя процесса>.
* Надо обозначить явно конец процесса - командой Закончить процесс. Имя процесса вряд ли пользователь в этом месте вспомнит.
* Оператор должен получать ввод и вывод консоли пользователя. Это уже есть в Логе, хотя нужно доработать, увязав с новыми требованиями.
* Это нужно представить в виде ЛентыСобытий - хронологической последовательности событий.
    * По сравнению с первым течением процесса, время между событиями в последующих запусках процесса может различаться. Нужно придерживаться среднестатистических величин, хотя важно знать и все значения всех повторных экземпляров процесса. Я обычно помню все значения, если они значительно различались в рамках одного процесса.
    * question: Что должно записываться в ЛентаСобытий?
    * question: Как событие должно записываться в ЛентаСобытий?
    * question: Что входит в свойства события?
    * question: Как должна происходить работа с ЛентаСобытий? Какие средства для этого нужны?
        * А) При записи процесса:
        * Б) При повторении процесса по ленте: 
* Процесс занимает только одну линию исполнения - маршрут. ЛентаСобытий отражает и хранит этот маршрут процесса как экземпляр процесса.
* При повторном исполнении процесса Оператор должен сверять события с ЛентаСобытий, и при несовпадении останавливать исполнение процесса (исполнение ленты)  
* Нужна ЛентаСобытий, подобная проекту машины времени. Нужен инструментарий Лент: хранилище Лент, система именования и поиска Лент, система навигации по лентам, группировки лент, статистической переработки лент в графы, ...
* Получится куча ЛентаСобытий процессов, по несколько лент на каждый процесс. Эти ленты в некоторый момент времени надо будет объединить в графовую модель процесса. На первое время - вручную, а потом будет видно.
* Процесс подобен диалогу [ДиалогПП], его начинает АгентИсполнитель, получив команду Начать процесс. И завершает он же по команде Закончить процесс. Благодяря этому в ЛентаСобытий не включаются сторонние сообщения, которые испортят последовательность событий.
    * Одновременно может быть начат и вестись только один процесс. Остальные процессы, диалоги команд итп должны ждать, пока завершится процесс, [ДиалогПП], и освободится КонсольДиалога. 
    * question: То есть, если активен [ДиалогПП], то все сообщения АгентИсполнитель должны попадать в КонсольДиалога? Иначе не получится записывать верную ЛентаСобытий.
    * КонсольДиалога должна вести свой собственный лог, в виде ЛентаСобытий? Это требует только единственный объект КонсольДиалога на все диалоги в процессе работы АгентИсполнитель по заданию - так и решено уже. 
* question: Это все про запись процесса в ЛентаСобытий. А как запустить воспроизведение процесса? 
* question: У процесса должно быть уникальное название. Как пользователь будет придумывать это название, тем более для некоторых процессов, вроде Открыть файл - они имеют схожее название, но разную последовательность действий. 
    * Придется больше работать над навыками придумывания названий? Это семантическая система, и в ней название определяет все. 
    * Можно получить список уже существующих процессов и через него найти новое название или уже существующий требуемый процесс. Это получается мини-справка по функциональности Оператора.
    * Это получается очень большая и сложная система. Без средств автоматического поддержания порядка я совсем не смогу с ней работать. Нужен опыт работы с Оператор, чтобы спроектировать всю эту возможность. 

 
++ Тема Процедуры

* todo: Надо обосновать и сделать тип для [Процедура], подобно типу для [Место].

+++1
Пока нельзя легко выделить [Процедура]у в самостоятельный объект. В ппрототипе [Процедура]а являлась частью [Команда]ы.
Процедура это функция из C#-кода, либо загружаемая из некоторой библиотеки, либо из самого Движка.
Например, обычно используется ShellExecute(file, args). Где file = путь к исполняемому файлу программы, args - аргументы программы. Либо же file описывает shell-объект.
Вот это - [Процедура]а. Одна [Процедура]а может быть сопоставлена нескольким программам. Еще надо сопоставить и аргументы [Команда]ы и [Процедура]ы.
todo: Придумать, как Пользователь будет сопоставлять аргументы [Команда]ы и аргументы [Процедура]ы.
    * Сейчас Процедура это либо командная строка для запуска через ShellExecute, либо путь к загружаемой из сборки функции.
    * В первом случае аргументы передаются по порядку следования.
    * Во втором случае аргументы Команды можно бы и соотнести с аргументами Процедуры по их имени. Если это возможно в коде, но вроде бы они тоже просто по порядку передаются.
    * Выводы: сейчас аргументы передаются по порядку следования, это универсальный способ. 

+++2 Проверка типов мест в теле процедуры
Еще была идея о том, что надо бы для места сразу указать тип места - плейлист и музыкальный файл. Иначе команда будет неправильная. Тогда она не должна исполняться.
Я помню, что тип аргумента должна проверять процедура команды.
Она должна отказывать в исполнении этой команды, если тип аргумента неподходящий.
Но сейчас у меня очень все примитивно, и всю работу делает ShellExecute. Никаких проверок аргументов нет. Да и процедур-то нет, кроме тестовой.
Значит, в процедурах надо предусмотреть проверку допустимости типов аргументов в коде процедуры. И отказывать исполнять, если тип аргумента неподходящий. Это надо сделать функцией АПИ - это ведь частая стандартная процедура. Только надо туда передавать списки допустимых типов аргументов. и еще битовый енум наследования типа: принадлежит подклассу Х, классу Х, надклассу Х, Х и его подклассам,  Х и его надклассам, Х его подклассам и надклассам.   

+++Процедуры
* В качестве приложения [Команда]ной строки можно вызывать cmd файлы. Они могут выполнять работы, но не могут возвращать результаты для использования в последующих [Команда]ах, сейчас.
    * Эти результаты можно было бы хранить в КонтекстЗадачи. Но пока у меня нет контекстов [Задача].
* В некоторых случаях приложение не может напрямую использовать аргументы из [Команда]ы, так как их нужно переработать и проверить по типам. То есть, должен использоваться код, значит, приложение должно запускаться из [Процедура]ы-из-кода, которое и выполняет переделку аргументов и проверку семантики [Команда]ы.
* [Процедура]ы выполняют конкретную обработку некоторой шаблонной [Команда]ы - строки.
  Например, Открыть %1. Для синонимов, например, Показать %1, уже надо другую [Процедура]у, хоть и с такими же свойствами. Но в данном случае и семантики у операции другая. Показать - для сущностей, которые можно просматривать (???).      
* С одной стороны, [Процедура]ы образуют инфраструктуру, так как они почти не меняются. С другой стороны, [Процедура]ы могут и меняться - исчезать и появляться. И вот это надо отслеживать. Иначе старые [Процедура]ы будут захламять систему. 
    * Можно предложить для [Процедура] хранить дату последнего обращения. И предлагать пользователю просмотреть и удалить давно не использовавшиеся [Процедура]ы. Не все [Процедура]ы можно удалить автоматически, и это должен решать пользователь - администратор системы. Но он должен тогда разбираться, что это за [Процедура]ы и с какими [Место]ами они работают. Чтобы не удалить важную [Процедура]у.
* Можно создать [Процедура]у для создания нового проекта и для бекапа проектов. А, нет, для бекапа нельзя - для него нужен архивный винт. Но можно было бы отслеживать подключение архивного винта и запрашивать пользователя не желает ли он сделать бекап.
    * Как так запрашивать пользователя, если он занят чем-то? в этой консоли нельзя проявлять инициативу - только ответ на запрос. Тут надо всю концепцию менять. Хотя бы трактовать событие подключения как запрос, и выводить сообщение об этом событии пользователю. 

Часть [Процедура] можно встроить в приложение. Наиболее частые и простые и не нуждающиеся в модификации.
Другие [Процедура]ы хранить в приложениях консольных или в длл-ках, подключаемых во временном домене приложения.
Приложения хороши тем, что в отдельном процессе исполняются, и не надо их выгружать. Плохи тем, что зависают и портят данные.

Если [Процедура]а, проверив данные, полученные из разбора аргументов [Команда]ы, нашла их неподходящими, то ищется следующее совпадение.
Если ничего не найдено, возвращается сообщение пользователю о том что система не может исполнить [Команда]у.

Для добавления [Процедура] в систему надо создать АПИ.

 [Процедура]е нужно передать ссылку на объект движка, распарсенные аргументы, копию [Команда]ы для лучшего разбора, ...
Процедура возвращает результат: Ошибка, неподходящая [Команда]а, успешное исполнение, ...

Цикл перебора [Процедура] использует возвращенное [Процедура]ой значение для работы.

У [Процедура]ы должно быть символьное название, по которому [Процедура]у можно вывести в список и представить пользователю.

+++Как записывать семантику процедуры
Для разных типов действий - разные названия классов действий.

Варианты:
А)оригинальный формат
сущность->действие->сущность
файл->найти->пользователь
файл->копировать->файл
сущность->добавить к->сущность

сущность->добавить в->контейнер<сущность>
Файл->добавить в->Папка<Файл, Папка>

Б) Си-подобный формат
сущность-результат = действие(сущность-аргумент);

Тут надо выбрать лучший способ записи. Но пока мало материала по теме. Надо накопить побольше [Процедура].
Вариант А) ближе к естественной грамматике русского языка. Но эту семантику важно определить, а потом уже будет легко привести ее к любому виду А) или Б).

+++Алгоритмы для Оператор
Надо придумать как создавать алгоритмы для исполнения команд Оператор.
-Алгоритм содержит номера строк - пунктов.
--А как быть с циклами и условиями? То есть, везде, где в C# стоят фигурные скобки { ?
-Алгоритм состоит из последовательности команд. Подобно Basic. Команды записываются естественным языком. Команды - это вот те самые команды, что сейчас в Операторе есть. Только их число и возможности надо увеличить.
- Как быть с отладкой алгоритма? Как просматривать значения переменных? Общее состояние дел?

Это похоже на Бейсик или Питон. Тут нужны служебные слова-операторы для управления потоком исполнения и для управления переменными.
- если операторы сделать русскими, то это будет похоже на 1С язык - там такие слова в качестве операторов образуют нелепые предложения.
- можно ввести небольшое распознавание смысла текста, тогда текст скрипта станет более естественным.
- а массивы тут не получаются, и индексы массивов не нужны?
-- Тут, наверно, получаются списки-коллекции. Фильтры сущностей отсеивают сущности из коллекций, образуя новые коллекции. И для всей коллекции применяются действия, подобно foreach оператору С#. Коллекции можно сортировать по какому-то свойству сущности, если это свойство есть у сущности. Коллекции могут включать сущности разных классов - это вроде List<Object>. А если свойства нет, то в сортировке вместо него значение null используется.
---Значит, классы сущностей тоже должны учитываться в таком алгоритме. А откуда брать эти классы? Определять их из текста описания алгоритма
? Или из контекста - Например, если коллекция это содержимое папки, то ее элементы это папки и/или файлы.
----Тут два понятия: классы, ожидаемые алгоритмом и классы реально участвующих в нем сущностей. Они могут не совпадать. Значит, надо и в реальном времени определять класс каждой сущности, чтобы избежать ошибок. Тогда как в обычном программировании предполагается, что классы реальных сущностей соответствуют ожидаемым. Почти никогда это не проверяется специально. Так как это очень много работы - для каждой сущности определить ее класс.
----А еще надо где-то хранить эти классы, их свойства и отношения между ними. Тут нужен Тапп. Хотя можно и файлами или БД обойтись, но и в них придется сделать Тапп-подобную систему. 

- а можно оператор цикла или условия представить как команду, которая реорганизует команды внутри скрипта? Она бы сама выбирала из скрипта свое тело цикла и отрабатывала его как вложенную задачу.
--тогда лучше уж распарсить весь скрипт в память как граф объектов-задач, и в нем запускать задачи (а не команды) на исполнение. Команды преобразовать в задачи.
Такой способ позволил бы доводить задачи до конца и останавливать выполнение алгоритма в точках, где состояние стабильное, и можно продолжить выполнение алгоритма на следующий день.

- кстати, как это все: 
-- как назвать точки, где алгоритм можно приостановить?
-- как отмечать текстом точки, где алгоритм можно приостановить?
-- как сохранять состояние алгоритма при приостановке алгоритма?
-- как определить, автоматически или вручную, что точка в алгоритме позволяет безопасно приостановить алгоритм? 
-- как распарсить алгоритм из текста в граф задач и потом сохранить его на диске, вместе со всеми переменными?
-- как учесть состояние внешних устройств, задействованных в алгоритме?
   Например, просить пользователя вставить флешку, которую он вчера вставил и запустил алгоритм, который не был затем завершен?

Возможно, нужно использовать что-то из мераматч для этого.

Но главная здесь сложность - как это все описывать обычным языком? Конечно, если алгоритм можно описать формальным языком, то его можно описать и обычным - он сложнее, чем формальный. Но вот как это реализовать? Мне прямо не хочется думать об этом.
- можно сначала накопить попытки описать алгоритм обычным языком. Потом выбрать из него удачные попытки. Потом накопить еще немного материалов и построить цельную картину. А потом целенаправленное интенсивное использование отшлифует и усовершенствует это мое изобретение.
- да это получается язык программирования! Еще один! И для него надо будет написать инструкцию самому себе! Иначе я его забуду.  


22:11 08.10.2017
Такой язык будет похож на бейсик, но больше вариантов предложений.
Поскольку тут усский язык, в нем всякие склонения-спряжения, и предложения будут различаться.
И еще, свободная форма предполагает, что будет много оборотов речи и разные формы выражений использоваться. Их просто надо запоминать и сопоставлять более четкой команде.
Но все равно, тут нужно четкое описание сущностей, присваивание им имен и использование по правилам. Это тоже довольно сложно.
Было бы неплохо для начала создать такой транслятор с русского на шарп, например. Чтобы описать алгоритм сначала текстом, а потом сгенерировать код как заготовку и уже в коде более четко описывать работу.
Для алгоритмов это годится, а как быть с данными: типами и классами? 
В них сложно описать структуру обычным языком? надо подумать. Надо пробовать. А так навскидку ничего не представляется.

+++Оператор методы
Оператор сейчас надо рассчитывать примерно на 1000 методов. В разных предметных областях. Команд же будет вдвое больше из-за их синонимов.
Нужны средства поиска методов по названию метода, описанию метода, типу аргументов, типу результатов. Поиск по частичному совпадению ключевых слов.
Нужны средства хранения алгоритмов и заголовков методов (в которых перечисляются аргументы, результаты и их порядок).
Нужны средства классификации методов, типов аргументов.
Нужны средства просмотра, редактирования, запуска и отладки алгоритмов.
Хорошо бы возложить на Оператор работы с Инвентарь, Коллекция Алгоритмов, Коллекция Данных, Менеджер Проектов, и другие мои подобные коллекции. Это сделает Оператор единой оболочкой для работы с частью моих дел. Хотя и не очень информативной оболочкой, но все же часть простых работ можно будет обернуть в простую для восприятия форму. 

+++процедуры для мест
в Оператор нужны процедуры для мест: 

-Покажи все %классМеста - показать программы, каталоги, файлы - все места указанного класса мест.
-Добавить место %место - добавить программу, каталог, файл
-Удалить место %место - удалить указанное место
-Покажи место %место

Надо другой термин придумать. "Место" не годится.
Эти процедуры встроенные или в первичной сборке процедур приложения.
Нужен АПИ для создания мест из кода.
Движок надо вынести в Длл, загружаемую приложением.
Нужна собственная БД
Нужна собственная система каталогов.

++ Очередность Процедур

Это способ поставить какую-то [Процедура]у раньше в последовательности перебора, чтобы она получила шанс обработать [Команда]у правильно, по сравнению с другими подобными [Процедура]ами. Для этого [Процедура]е присваивается некий номер, и она в списке подобранных [Процедура] оказывается раньше других с худшими номерами. Это предполагает, что будет создаваться список [Процедура] - кандидатов на исполнения. То есть, будут проверяться все регексы в БД, кроме тех что уж явно не подходят по регексу и [Команда]е. Это будет очень трудоемко. Хотя можно сортировать все [Процедура]ы до проверок, это существенно снизит трудоемкость, но потребует держать в памяти все записи таблицы.

Можно при сортировке проводить первичный отбор выражений - выделять в текстах выражений места для аргументов и места текстовых шаблонов, и отсекать по первым трем символам [Команда]ы все выражения, что не укладываются в начальный текстовый шаблон. Например, шаблон ^копировать %0$ отберется для [Команда]ы: Копать здесь  

Это число - такой Вес для [Процедура]ы. Можно в виде double назначить, чтобы не заморачиваться с пространством чисел. Тогда всегда можно назначить число, больше или меньше существующего.

Проблема в том, что в разных ситуациях у [Процедура]ы должен быть разный вес относительно других [Процедура].
Пока эти ситуации не изучены, лучше сосредоточиться на более реальных проблемах. 

+++Автоматическое распределение веса процедур
Рассмотрим команды:
1) Открыть %файл в %папке
2) Открыть %место
3) %команда

Тут наглядно видно, что [Команда]а 2) включает в себя [Команда]у 1). А [Команда]а 3) включает в себя все возможные [Команда]ы.
Следовательно, [Процедура]а-обработчик [Команда]ы 1) должна вызываться раньше, чем [Процедура]а-обработчик [Команда]ы 2). А [Процедура]а-обработчик [Команда]ы 3) должна быть самой последней в этом списке [Процедура].
Этот порядок задается весами [Процедура]. [Процедура]ы в общем списке [Процедура] сортируются по весу.
Таким образом, можно автоматически построить иерархию обработчиков от общего 3) к частным 1). И назначить их веса так, чтобы наиболее общие обработчики оказыались внизу, а наиболее частные - вверху списка [Процедура].
Еще этот способ выявит дублирующиеся [Процедура]ы в системе (по структуре [Команда]ы). Это повысит предсказуемость системы.

Еще, если держать именно дерево, то можно не перебирать все [Процедура]ы в списке, а идти по ветке первого слова [Команда]ы. Это сократит число перебираемых кандидатов в [Процедура]ы. Доставлять [Команда]у к той [Процедура]е, для которой максимально совпадает шаблон и [Команда]а. А потом спускаться вниз к более общим узлам дерева 3).

На 3) можно повесить функцию сбора необработанных запросов и вывод сообщения Я не умею это.

Еще могут быть семантически разные, но одинаковые по шаблону [Процедура]ы. В них аргументы проверяются по типам или значениям, и соответственно принимается решение - выполнять [Процедура]у или нет. Такие [Процедура]ы должны иметь равный вес и перебираться последовательно.
Но их шаблоны будут одинаковыми и они при автоматической проверке будут считаться одинаковыми. Это надо учитывать.
Хотя у таких [Процедура] будет разная семантика, и если для [Процедура]ы описать и хранить семантику, то можно по ней различать [Процедура]ы.

Проблема в автоматизации тут в том, что есть и шаблоны-регексы. Они могут быть слишком сложными для такого анализа. Поэтому само их наличие делает это определение веса [Процедура]ы преимущественно ручной операцией.
Можно предложить для простых шаблонов определять вес автоматически, а для регексов - вручную.
Но пока все [Процедура]ы определяются вручную, это не существенная проблема.

++ Операции Создания Процедур Через РИ

Процедуры было бы естественно создавать через РИ. 
Вынести это в отдельную [Процедура]у.

+++Создание процедуры
//ввод имени [Процедура]ы
--> Создать процедуру Копирование файла  (паттерн: ^создать процедуру %arg0$)
Может оказаться что такое имя уже существует, надо вывести сообщение.
//выявление типа регулярного выражения разбора [Команда]ы
<-- Разбор команды будет использовать регулярные выражения, которые надо вводить вручную? 
--> Да /Нет/отмена

//завершение работы пользователем
А) Если пользователь ввел Отмена, то [Алгоритм] завершает работу. Отмена /отменить / прекратить /остановить.

//получение чистого регулярного выражения
Б) Если пользователь ввел Да, то:
<-- Введите регулярное выражение. Используйте справочную документацию, чтобы правильно составить регулярное выражение.
--> ^регулярное выражение как есть$ / отмена (выражение должно начинаться с ^ и кончаться $, иначе это не регулярное выражение, а попытка отмены или неведомая фигня)
Может оказаться что такое выражение уже существует, надо вывести сообщение.

//получение упрощенного регулярного выражения
В) Если пользователь ввел Нет, то:
<-- Введите паттерн разбора команды  (тут надо определиться с терминами)
--> Копировать файл %0 в папку %1 / отмена  (тут ключевое слово отмена и его синонимы исключают их использование в качестве регулярного выражения, это должно быть прошито в коде)
Этот простой регекс кодом парсится и превращается в стандартное регулярное выражение, которое и проверяется при вводе [Команда]ы [Процедура]ы.
Может оказаться что такое выражение уже существует, надо вывести сообщение.

Получение остальных свойств проводится таким же образом, тоже с возможностью завершения работы.

В качестве исполнителя может использоваться программа или функция сборки.
Для программы задается путь к программе и строка аргументов, тоже простым паттерном подстановки или сложным регексом замены. Простой от сложного различается кодом по символам ^ и $ начальным и конечным.
Для функции в сборке задается путь к сборке, имя класса и статической функции, как в тапп1, потом аргументы, разделенные пробелами, подобно тому, как указано выше для приложения.  

+++Удаление процедуры
* todo: Добавить текст здесь
+++Редактирование свойств процедуры
* todo: Добавить текст здесь
+++Просмотр свойств процедуры
* todo: Добавить текст здесь
+++Получение общего списка процедур
* todo: Добавить текст здесь

++ Тема Рекурсия Процедур

* Нужно сделать поддержку рекурсивного использования Механизма, чтобы вызывать его из сборок для выполнения других запросов из других сборок.
    * Надо сделать отдельный АПИ для использования Механизма из кода сборок.
    * Еще нужен АПИ для поиска и вызова [Место] и [Процедура] из кода [Процедура]ы.
    * Надо сделать функции для ввода и для вывода в консоль.
    * Надо сделать лог с настраивемой детализацией. Эту детализацию регулировать через [Команда]ы консоли.
    * Каждый вызов надо фиксировать в логах. И надо как-то отмечать для лога глубину вложенности вызовов. Иначе будет трудно отлаживать сложные [Процедура]ы.
    * Можно предложить ограничение глубины вложенности, чтобы хотя бы приостанавливать выполнение если программа в рекурсию углубилась. Выводить пользователю сообщение о превышении порога рекурсии и спрашивать, хочет ли он продолжить. Можно назначить несколько порогов рекурсии: 10, 100, 1000, 10000 итд.
    * Если Механизм будет рекурсиво вызывать [Процедура]ы, как он будет обрабатывать возвращаемые ими значения? [Процедура]ы же предназначены для пользователя и выводят результаты в консоль, если вообще что-то выводят. Механизм должен позволять [Процедура]е читать результаты вызываемых [Процедура]?
        * Похоже, я смешал [Процедура]ы и концепцию программирования. Получилось что-то вроде проекта Math. Так не получится в этой системе. Тут [Процедура]ы не возвращают значения, так как некому их разбирать. Вместо этого, [Процедура]ы запускают скрипты, в которых пользователь делает всю работу без использования Механизма и его возможностей. 
        * Это делает Оператора более неуклюжим в плане архитектуры - он обрабатывает только входные случаи, в едином потоке - от входа до выхода, и не использует наработки пользователя повторно.
        * Можно использовать другие [Процедура]ы в сборке через [Команда]ы, но такие, что не возвращают результат. Поскольку даже сообщение об ошибке [Процедура]а толком не выдает, то сложных [Алгоритм]ов на этом не сделать.
        * Это все же оболочка пользователя, а не ИИ. Так как оно само не может строить [Алгоритм]ы, да и пользователь не сможет, то и ИИ из него не выйдет. Эта штука будет делать только то что в нее добавили и так, как продумали.
        * Зато эта штука будет собирать материалы для разработки новой концепции и новой версии. Это, в общем-то, и является ее основной задачей. И еще она будет немного работы делать полезной, упрощать мою работу на компьютере.  
        
+++Поддержка рекурсии движка
Эти строки запускают [Процедура]ы. А эти [Процедура]ы, в свою очередь, могут вести последовательные диалоги с распознаванием текста и запускать другие подобные [Процедура]ы. То есть, [Процедура]а тоже может использовать этот механизм окна консоли и БД выражений, рекурсивно. Окно консоли и весь этот движок передаются запускаемой [Процедура]е по ссылке, и она его использует так же, как вызывающая [Процедура]а. Ну или почти так же.

++ Тема Агент Исполнитель - проработать концепцию для включения в текущий релиз.
Эту тему с исполнителями надо проработать. Она хорошо (кажется) вписывается в  общую концепцию Оператор.
* Перенести все тексты по теме на страницу ТемаАгентИсполнитель - сделано на 15.08.2018 01:52 
* Переработать тексты для внесения в концепцию Оператора.
* Эта идея влияет на другие решения в разных темах. Надо поместить ссылки на идею и следствия принятых архитектурных решений в эти другие темы.
* Надо составить перечень фактов и решений для облегчения разработки концепции.
    * Решения и факты извлечены из текущего списка материалов: 16.08.2018 09:49 
* Надо составить список вопросов для проработки темы - вопросы поставлены 16.08.2018 09:49.

Материалы: ТемаМногозадачность, ТемаИсполнениеКоманд.

+++Список фактов и решений
++++Окно консоли
* Текущий релиз Оператора должен обрабатывать внешние события.
* Каждое внешнее событие может запустить собственную задачу реакции на событие.
* Возможно поступление множества внешних событий одновременно.
* Текущий релиз Оператора должен поддерживать многозадачность.
* Текущий релиз Оператора должен иметь только одно ОкноКонсоли для диалога с пользователем.
* Все задачи разделяют одно общее ОкноКонсоли.
* Задачи реакции на события нужно организовать так, чтобы они не использовали диалоги с пользователем.
* Задачи реакции на события могут выводить сообщения в ОкноКонсоли, но желательно этого не делать. 
* Диалог с пользователем блокирует ОкноКонсоли до своего завершения. 
* Если пользователь не может закончить диалог, то все другие задания оказываются заблокированными.
* Во время диалога сообщения других задач на консоль не должны выводиться, чтобы не разрушать контекст диалога. Это неудобно, если диалоги очень длинные. 
    * question: Как реализовать диалог одновременно с выводом сообщений других задач? 
    * question: Что такое контекст диалога? Как его хранить?
* Для сложных задач удобно было бы выделить собственное ОкноКонсоли. Но это надо продумать отдельно и нужен опыт эксплуатации Оператора в таких задачах. 
* Команды Break и Pause останавливают исполнение задач Оператора.
* При разборе команды нужно выявлять имена исполнителей - ИдентификаторАгентаИсполнителя, с учетом их склонений.
* Сейчас Оператор должен просто разобрать команду, найти сопоставленную процедуру и выполнить ее. Никакого интеллекта и понимания сути запроса не требуется.

++++агенты - исполнители
* Вместо идентификации заданий по их названиям в Оператор решено применять идентификацию заданий по исполнителям. Это более человекоподобно и более просто реализовать технически. 
* * Каждая задача поручается одному из АгентИсполнитель, который не занят другой текущей задачей.
    * done: Как выбирать свободного исполнителя из пула исполнителей?
        * Это функция, возвращающая объект АгентИсполнитель, первый попавшийся свободный. Или null, если нет свободных.
        * Просмотром массива исполнителей выбрать из него первый попавшийся свободный.
            * Если ни одного свободного нет, то вывести пользователю сообщение, что все исполнители заняты.
            * А что дальше? 
                * А) поставить команду в очередь ожидающих команд и ждать освобождения любого исполнителя.
                * Б) предложить повторить команду позднее. 
                    * Это не позволит выполнять скрипты автоматические, если система перегружена заданиями. Хотя это значит, что система уже не справляется.
                    * Вариант с ожиданием лучше, он позволил бы выполнить все-таки все задачи скрипта, но медленно.
                    * Я пока не знаю, что лучше, что хуже. Эта ситуация гипотетическая.   
    * done: Как получить список свободных исполнителей?
        * Это функция, возвращающая список объектов АгентИсполнитель.
        * Просмотром массива исполнителей выбрать из него все свободные АгентИсполнитель и внести их в возвращаемый список. 
        * А где этот список будет использоваться? Вывести пользователю: Сейчас свободны Иван, Петр, Федор. Так без толку - через миллисекунду Иван будет занят внешним событием. 
            * Можно на внешние события брать АгентИсполнитель из конца массива, чтобы пользователю доставались его любимчики, имена которых он часто использует и помнит хорошо.
        * А если вот на внешнее событие - нет свободного исполнителя? Важное событие.
            * Ставить его в очередь ожидающих команд?
            * Похожий пример есть в оконных сообщениях. Там тоже если обработчик не успевает обрабатывать собщения, они хранятся в очереди сообщений, и удаляются согласно таймштампу добавления в очередь. И там два порядка обработки сообщений - общий и срочный. Но там они по классам разделены четко. А у меня тут все неопределенно пока.   
    * done: Как определить, занят ли некоторый исполнитель и чем именно?
        * Иван, что ты делаешь? -  Иван: <Текст команды:> Включить плеер. 
            Иван, прекрати работу. 
    * done: Как показывать общий список исполнителей и чем они заняты?
        * Команда  Покажи исполнителей. или Что делают исполнители?
            Иван: свободен
            Федор: свободен
            Вадим: <Текст команды:> Качать торрент ххх
    * question: Как указать конкретного исполнителя для задачи пользователя?
    * done: Как быть, если указанный исполнитель уже занят другой задачей? 
        * сообщать что указанный исполнитель занят и предлагать другого. Например: Иван, включи плеер. - Иван занят, Федор свободен. - Федор, включи плеер.
    * question: Как отменить или приостановить работу указанного исполнителя?
        * Команда Иван стой или Иван стоп или Иван подожди - приостановить задачу исполнителя
        * Команда Иван продолжай или Иван продолжить работу - возобновить задачу исполнителя, если она была приостановлена.
        * Команда Иван прекрати или Иван отмена - отменить выполнение задачи исполнителя. 
            * Однако, отката изменений данных обратно не будет, это надо учитывать.    
* В Оператор должен существовать массив АгентИсполнитель с уникальными именами ИдентификаторАгентаИсполнителя.
* Пользователь может использовать эти ИдентификаторАгентаИсполнителя для более естественного управления при речевом взаимодействии с Оператором.
* Все АгентИсполнитель одинаковы по своим свойствам и возможностям.
* Каждый АгентИсполнитель это отдельный поток исполнения.
* Если АгентИсполнитель простаивает, его поток исполнения остановлен.
* ИдентификаторАгентаИсполнителя должен быть коротким именем, привычным пользователю. 
    * Пример: Боря, Ваня, Вадя, Вася, Гоша, Геша, Гриша, Дима, Женя, Коля, Леша, Мотя, Миша, Паша, Петя, Рома, Саша, Федя. 
    * done: найти список имен в проекте Words и собрать из них уменьшительные имена сюда. Заодно, сопоставить уменьшительные и обычные имена там в списке, пригодятся потом. См. ИменаАгентИсполнитель
* Каждый ИдентификаторАгентаИсполнителя является термином, обозначающим Сущность-АгентИсполнитель  в запросах пользователя, и должен обрабатываться подобно Месту в запросах пользователя. 
    * question: Как еще используется ИдентификаторАгентаИсполнителя с точки зрения пользователя?
    * question: Привести примеры использования ИдентификаторАгентаИсполнителя в одиночных командах и диалогах. По 5 штук и более.  (Надо вообразить это и целый день генерировать диалоги и одиночные запросы)
    * question: Как отображать ИдентификаторАгентаИсполнителя в выводе на ОкноКонсоли? Нужно удобное решение для всех случаев.
        * Сначала нужен этот список случаев вывода ИдентификаторАгентаИсполнителя на ОкноКонсоли.
        * Общий случай - ИдентификаторАгентаИсполнителя в первичной форме склонения. В табличном виде - разделять двоеточием. Например: Иван: Открыть плеер. Петр: Найти все файлы рисунков в моих документах. 
* Должен существовать пул исполнителей заданий - массив агентов АгентИсполнитель.
    * Предлагается 16 исполнителей заданий - массив из 16 объектов АгентИсполнитель.
    * Массив инициализируется при старте Движка, но потоки создаются по мере необходимости, а не сразу при старте.
* Сообщения от агентов АгентИсполнитель выводятся на ОкноКонасоли подобно чату с несколькими людьми. ИдентификаторАгентаИсполнителя позволяет сообщениям не перемешиваться в общем листинге. Однако, только один АгентИсполнитель может вести диалог с пользователем в один момент времени до окончания диалога. Иначе пользователь совсем запутается в этих диалогах.
* В Лог агенты АгентИсполнитель выводят сообщения от своего имени. Также, есть системные имена агентов User, Operator, System. Они используются для обозначения источников записей лога, созданных соответственно, пользователем, оператором, и тоже оператором. Поэтому, хотя в Логе сообщения нельзя группировать по сеансам и транзакциям лога, как в Тапп, они все же сохраняют возможность разобраться, кто и что делал одновременно.
* В скриптовой процедуре команды должен использоваться только один АгентИсполнитель. Иначе скрипт будет работать непредсказуемо неправильно, если свободных исполнителей не окажется. И пользователь будет недоволен, если для него не найдется свободного исполнителя.
    * Даже если скрипт будет использовать исполнителей асинхронно, ему придется ждать, когда освободится исполнитель. И тут могут быть проблемы с блокировками доступа потоков АгентИсполнитель к ресурсам. Мне не хочется добавлять средства синхронизации потоков в код скриптов Оператора. 
* Свойства механизма исполнения процедур:
    * Для команды может быть найдено несколько процедур.
    * Процедура может отказаться от исполнения входной команды, поскольку определила, что команда для нее не подходит.
    * Процедура может переопределить команду и перезапустить для нее поиск процедур.
* Каждый АгентИсполнитель должен работать в отдельном домене Оператор, чтобы сбой в нем не завершил сам Оператор.
    * question: Это возможно? Как это реализовать? Как изолировать основной процесс Оператор от аварии с АгентИсполнитель? 
        * Класс AppDomain фреймворка представляет отдельный домен внутри одного процесса. 
            * Можно выгрузить домен без выгрузки всего приложения.   
            * Можно перехватить исключение AppDomain.UnhandledException в AppDomain. Но я не уверен, что оно не завершит весь процесс - это надо уточнять на тестовом образце.
        * В общем, в МСДН все мутно написано, и я думаю, это будет существенная тема для экспериментов. С многопоточностью и коллбеками и маршалингом можно заблудиться в ней на полгода и более. И все равно после внедрения что-то может пойти не так.  
* Нужен монопольный доступ каждого АгентИсполнитель к данным и файлам внутри Оператора.
    * question: Это возможно? Как это реализовать?
    * Посмотреть на веб-сервер - там похоже.
* Нужен монопольный доступ каждого АгентИсполнитель к данным и файлам вне Оператора.
    * question: Это возможно? Как это реализовать?
    * Посмотреть на веб-сервер - там похоже.
* Каждый АгентИсполнитель должен сообщить пользователю через ОкноКонсоли о завершении задания и его результате.
* Если длительный процесс выполняется сторонним приложением, АгентИсполнитель должен запустить его процесс и ждать завершения этого процесса. 
    * Таймаут ожидания завершения процесса я совершенно не могу определить - зависит от конкретной задачи.
    * При работе приложения могут возникнуть сбои. Код завершения процесса не всегда выдается.
    * Надо еще контролировать работу/простой процесса.
* Сообщения от АгентИсполнитель должны попадать в лог Оператора.
    * question: как это реализовать? 
* Команды управления исполнением от Оператора должны попадать к АгентИсполнитель.  
    * question: как это реализовать?
* Возможно, АгентИсполнитель удобнее будет реализовать как мини-сервер с входными командами и выходными сообщениями.
   Как отдельный процесс, подобно веб-серверу Apache. Там тоже есть множество копий, разделение доступа к файлам между копиями, синхронизация ожидания доступа, общий канал лога, итп.


+++Список вопросов для проработки темы
* question: как должна быть устроена архитектура Оператора для реализации принятых здесь решений?
    * ОкноКонсоли отправляет и принимает тексты пользователя Движку.
    * Движок проводит первичный анализ команды и выявляет Сущности. 
        * Выявляет ИдентификаторАгентаИсполнителя.
    * Движок перенаправляет запрос подходящему АгентИсполнитель, одному из нескольких имеющихся простаивающих.
    * АгентИсполнитель выполняет подходящую процедуру и возвращает результат.
    * ...
* done: можно ли приостановить выполнение начатой задачи на длительное время, с выключением питания компьютера?
    * Если просто - то нет. Нужна поддержка на уровне ОС.
    * Для этого надо, как минимум, сохранить состояние переменных алгоритма процедуры - это возможно только если процедура исполняется пошаговым интерпретатором вроде Бейсика, и он умеет сохранять это состояние в файл. Но еще есть открытые файлы и другие внешние ресурсы. Их не получится сохранить.
* todo: Нужно продумать, как реализовать разделяемый одновременный доступ потоков-исполнителей к одному и тому же файлу, ресурсу, реестру, итп. В однозадачной версии этой проблемы не было, а теперь это *может оказаться критически важной проблемой Оператора*.

++Переработка агент исполнитель
+++Сходство Оператор и Тапп
Тут есть идея о сходстве Оператор и Тапп в архитектуре. 
Можно бы подумать, как реализовать Оператор на Тапп. Чтобы использовать преимущества Тапп и функционал Оператора.
Но пока и Тапп и Оператор - один большой эксперимент. Этим можно заняться позже, когда будет больше опыта.
И когда будет готов и пригоден для работы и Тапп и Оператор.

+++Транзакции и откат изменений
* Интересны были бы транзакции и откат изменений, сделанных при исполнении процедуры. Если их можно откатить - для этого нужно каждой процедуре сопоставлять процедуру обратную. 
    * Это слишком сложно пока. Отложим все это на будущее. Отложено на ТретийПрототипКонсолиРИ.

+++Подсистема лога
* Лог пока будет простой последовательностью сообщений.
* Сообщение лога требует название агента отдельным полем. Наличие названия агента позволяет пользователю установить источник сообщения и восстановить весь ход работы агента в файле лога, где все одновременные сообщения перемешаны.


+++Окно консоли
* Оператор может запускать одновременно несколько задач. Это задачи пользовательских команд и задачи реакций на внешние события.
* Но все они разделяют одно окно консоли. И все их сообщения на консоли будут в этом случае вперемешку отображаться.
* Поэтому задачи реакций на внешние события должны минимально использовать вывод на консоль сообщений, а диалоги с пользователем использовать только в крайних случаях.
* Особенно ожидать ввода пользователя - он не понимает, что он сейчас должен вводить, кому отвечать.
* Чтобы все это разрулить правильно, надо для каждого задания показывать собственное окно консоли. Но тогда получится неудобно для пользователя. На каждую задачу будет открыто собственное окно консоли, как в Windows cmd, пользователь должен будет между ними переключаться, чтобы узнать, какие это процессы, в каком они состоянии, завершились ли они, закрывать их. Так у Оператора мало отличий от cmd или Bash получается. А еще есть задачи реакций на внешние события, они будут постоянно показывать свои окна, и пользователь должен будет их закрывать вручную - ему некогда работать будет. 
* А если окна закрывать автоматически, а не вручную, то пользователь не узнает, что в них было и чем кончилось.
* Поэтому сейчас предполагается только одно окно консоли. И в нем одновременно только одна задача может начатьи вести диалог с пользователем. И вот я пока не знаю, как во время этого диалога показывать сообщения-не диалоги от других задач.
* Для мелких заданий можно совмещать окно консоли. Например, плеер запустить и управлять его работой.
* А для более длительных, сложных и насыщенных диалогами задач удобно заводить отдельную консоль. Вроде разработки проектов или управления проектами. Но таких процессов у меня пока нет, а может быть, там потребуются другие решения. 
* Вот это сейчас надо на одноконсольном варианте Оператор опробовать.

+++Схема исполнения задачи
* В однозадачной схеме, старой, только одна команда могла выполняться одновременно. Пока она выполняется, остальые ждут в очереди команд.
* Команды Break и Pause останавливают исполнение этого одного потока исполнения. Хотя в старой схеме они не были реализованы.
* Но теперь в Оператор много разных каналов внешних событий. Они не могут ждать, пока пользовательская задача завершится. И наоборот, пользователь не хочет ждать, когда Оператор освободится от обработки событий.
* Тут важны свойства механизма исполнения процедур:
    * Для команды может быть найдено несколько процедур.
    * Процедура может отказаться от исполнения входной команды, поскольку определила, что команда для нее не подходит.
    * Процедура может переопределить команду и перезапустить для нее поиск процедур. 

* Надо придумать способ одновременного исполнения нескольких заданий.
    * А) Можно подбор процедуры для команды сделать одним потоком, а исполнять найденную процедуру - другим потоком.
Основной поток движка находит процедуру и отдает ее одному из рабочих потоков - Исполнителей.
        * не получится из-за свойств механизма исполнения процедур. Нужен один поток на поиск процедуры для команды и ее исполнение. 
        * Значит, исполнение команды делается одним потоком целиком.
        * К БД и данным Оператора и компьютера придется монопольный доступ потока делать. И для лога тоже.
    * Б) Выборку процедур для команды из БД делает основной поток Движка. Он разбирает команду, собирает сущности. Из БД получает список процедур для команды, сортирует его по весам. Отдает список процедур и разобранную команду потоку-исполнителю. Поток-исполнитель делает собственно исполнение команды из процедур в списке.
        * Тут БД используется одним потоком Движка. Список процедур обрабатывается потоком-исполнителем. Если поцедура переопределяет команду, то новая команда просто отправляется в Движок заново, и все снова происходит по этому же алгоритму.
        * К данным Оператора и компьютера придется монопольный доступ потока делать. И для лога тоже.
        * И есть команды, которые используют данные из БД. Например: Покажи места. Тут поток-исполнитель должен извлечь места из БД и составить список и вывести на консоль пользователю. И никак тут не отвертишься от многопоточного доступа к БД. А если он все равно нужен, то зачем лишние сложности - надо делать как лучше и проще.
    * *выводы:*
        * И А)и Б)способы не годятся. Они очень похожи и различаются только моментом разделения исполнения между потоками. Надо тогда обратиться к точному алгоритму исполнения команды, чтобы определить, где его можно правильно разделить между потоками.
        * И в А) и в Б) есть общие решения: поток-исполнитель получает задание от потока Движка, выбирает процедуру, выполняет задание, представляет результаты пользователю и завершает свою работу. 
        * Причем важно вынести это исполнение в отдельный домен приложения, чтобы оно не влияло на работу Оператора, если возникнет  сбой.
            * question: какие свойства у этого исполнения в отдельном домене приложения Оператор? 
        * А поток Движка делает некоторую работу по предварительной подготовке задачи и отправке ее потоку- исполнителю.
        * Нужен многопоточный лог. Как в Тапп.
        * todo: Нужно продумать, как реализовать разделяемый одновременный доступ потоков-исполнителей к одному и тому же файлу, ресурсу, реестру, итп. В однозадачной версии этой проблемы не было, а теперь это *может оказаться критически важной проблемой Оператора*.

+++Потоки исполнения команд
Для архивов хорошо бы, чтобы Оператор мог сообщить пользователю о завершении сжатия или распаковки большого объема. Ну и вообще, сообщить о завершении длительного процесса. И сам этот процесс не должен делать Оператор недоступным, ожидающим завершения процесса. 
Для этого Оператор должен дождаться завершения процесса архиватора и вывести сообщение о результате пользователю. Для этого надо каждый запуск [Процедура]ы выделять в отдельный поток, чтобы он мог следить за процессом, ожидать его завершения и производить пост-обработку.
    * А как сообщения из такого временного потока отправлять в Лог и в ГУЙ?
        * Через специальные каналы сообщений. Которые собирают сообщения в свою очередь и потом выводят в лог и на экран пользователю. 
        * Такие [Задача]и без КонтекстЗадачи плохо реализовывать. Хотя и возможно. Но вот как отменить [Команда]у Сжать архив Х, если она не синхронная? Если я уже пять таких запустил, и не знаю теперь, какая тут на экране какая? Пока можно просто диалог сжатия мышкой отменить, а то бы и вовсе никак нельзя было вмешаться через Оператор-то.
        * То есть, для каналов нужно создать Ивент и приемник сообщений отдельно для Лога и для Гуя от потоков исполнения [Процедура]. ПотокИсполненияПроцедуры будет подключаться к этим ивентам при создании  и отключаться при завершении. Поток будет оправлять сообщения в каналы Лог и Гуй. Эти сообщения должны помещаться в очередь, чтобы не перебивать друг друга.
        * Эта инфраструктура пригодится при внедрении КонтекстЗадачи потом.
* Эта концепция предполагает создание внутри Оператора массива виртуальных исполнителей АгентИсполнитель. 
    * todo: проработать эту тему, я хочу реализовать ее в текущем релизе Оператора. См. ТемаАгентИсполнитель.
    * Каждый агент может выполнять собственное задание, команду. Или может простаивать - как виртуальный исполнитель, разумеется.    
    * Каждый АгентИсполнитель имеет собственный поток исполнения и сам выполняет свое задание.
    * Агент имеет собственное название, которое зарегистрировано как место-Сущность специального класса. Пользователь может использовать эти имена агентов для более естественного управления при речевом взаимодействии с Оператором.
    * Сообщения от агентов выводятся на консоль Оператора подобно чату с несколькими людьми. Логин агента позволяет сообщениям не перемешиваться в общем листинге. Однако, только один агент может вести диалог с пользователем в один момент времени до окончания диалога. Иначе пользователь совсем запутается в этих диалогах.
    * В Лог агенты выводят сообщения от своего имени. Также, есть системные имена агентов User, Operator, System. Они используются для обозначения источников записей лога, созданных соответственно, пользователем, оператором, и тоже оператором. Поэтому, хотя в Логе сообщения нельзя группировать по сеансам и транзакциям лога, как в Тапп, они все же сохраняют возможность разобраться, кто и что делал одновременно.

+++Исполнители с именами
Чтобы выводить диалоги разных заданий на одну консоль, нужно присвоить их исполнителям имена (текстовый идентификатор-аббревиатура). Тогда пользователь не будет путать диалоги вперемешку.
Однако оказалось, что одновременно вести несколько диалогов очень неудобно и чревато путаницей и ошибками. 

Например:
Открыть сайт ххх и играть музыку

Иван: Открываю сайт ххх.ком
Федор: Запускаю плеер.
Иван: что дальше делать с сайтом?
Федор: Увеличить яркость экрана?

Как пользователь на это будет отвечать?

Иван, закрой сайт.
Федор, играть свежую музыку.

Или?

Иван, скачай все музыкальные файлы по ссылкам на странице.
Федор, собери эти файлы в плейлист и играй на плеере.


Выводы:
1. Это слишком сложно. Два задания должны взаимодействовать, тут нужен ИИ.
Который будет и за Ивана, и за Федора делать работу.
2. Алгоритм работы тут задан, но он не продуман предварительно пользователем. Тут надо:
-найти на странице все ссылки на музыкальные файлы.
-найти место для размещения скачиваемых файлов
-скачать музыкальные файлы по ссылкам
-создать новый плейлист и добавить в него скачанные файлы
-запустить плеер с этим плейлистом.
Это мог бы делать один исполнитель, но в команде указаны два. И они должны координировать свою работу.
Федор должен ждать, пока Иван скачает новый файл, и после этого добавить его в плейлист.
И наверно сразу же играть на плеере.
Получается, нужен ИИ, который разберет два алгоритма заданий Ивана и Федора, создаст из них конвейер, новый алгоритм.


В целом, пример неправильный. Пока только один диалог может вестись в консоли одновременно.
Так как для диалога надо хранить контекст задания.  
 
Имена в качестве ИД исполнителей - удачное решение. Их легко выделить из текстов команд. Они обозначают сущности - исполнителей.
* То есть, теперь в команде при разборе еще надо выявлять имена исполнителей.
* а если указанный исполнитель занят, то как быть?
    * сообщать что указанный исполнитель занят и предлагать другого. Например: Иван, включи плеер. - Иван занят, Федор свободен. - Федор, включи плеер.
* массива из 16 исполнителей будет достаточно?
    * Только пока в скриптовых процедурах команд используется только один исполнитель. Но со временем и они займут всех исполнителей работой.
* Удобно контролировать загруженность системы: Покажи исполнителей. или Что делают исполнители?
Иван: свободен
Федор: свободен
Вадим: Качать торрент ххх

Пока имена исполнителей не были нужны, так как ранее в Операторе предполагалось только один исполнитель, только одно задание одновременно.
Теперь есть задания из канала событий, и их придется как-то реализовывать одновременно с работой пользователя.
Возможно, следует сделать пул исполнителей заданий. И тогда присвоить им имена.
Но эта концепция пока набросок отрывочный. Ее надо проработать, развить идею.
Имена исполнителей - лучше, чем идентификаторы заданий. Человекоподобнее. 
Идентификаторы заданий еще придумать надо, из текстов команд, и по ним не поймешь, о чем они.
Имена исполнителей тоже ничего не говорят о задании, но их проще запомнить и они привычны для такого использования.
Исполнителя можно командой спросить что он делает:
Иван, что ты делаешь? -  Иван: <Текст команды:> Включить плеер.
Иван, прекрати работу. 

++Диалоги с пользователем
Это диалог не вообще, а внутри исполнения процедуры, для ввода пользователем дополнительных указаний в форме ответов на вопросы исполнителя.
Он должен быть похож на обычный диалог между начальником и подчиненным, насколько это получится.

* Оператор должен предварительно обрабатывать ввод пользователя для [ДиалогПП]а, подставлять в них Места, выявлять команды отмены [ДиалогПП]а, значения по умолчанию, завершения исполнения задачи.
* На время [ДиалогПП]а Движок не должен считать ввод с консоли - командами. 
Он должен отправлять их в АгентИсполнитель. Для этого АгентИсполнитель должен запросить и получить от Движка объект КонсольДиалога.
КонсольДиалога это представление консоли пользователя для ввода-вывода текстов на время [ДиалогПП]а.
Когда АгентИсполнитель получит КонсольДиалога, Движок отправляет АгентИсполнитель через эту КонсольДиалога ввод и вывод консоли пользователя, пока АгентИсполнитель не освободит консоль явным вызовом функции.
* question: а если вложенная процедура тоже использует [ДиалогПП] и КонсольДиалога, то надо считать уровни вложенного использования в команде? Чтобы не освободить КонсольДиалога раньше времени. 
* question: А если процедура забудет освободить КонсольДиалога, то ее надо освободить по завершению процедуры, или по окончанию задания Исполнителем АгентИсполнитель.
КонсольДиалога всего одна, хранится в Движке, передается и хранится у АгентИсполнитель. 
Только АгентИсполнитель может читать и писать из/в КонсольДиалога в любой исполяемой им процедуре.

* question: есть ли таймаут ожидания ввода в КонсольДиалога? Если пользователь забил на диалог? 
    * Если он забил на один [ДиалогПП], зачем показывать другой [ДиалогПП]? Пусть ждет, когда пользователь решит продолжить.

+++Как АгентИсполнитель работает с КонсольДиалога?
* Он получает КонсольДиалога функцией Движка getConsoleWait(), в которой он ждет освобождения КонсольДиалога для своего потока.
    * Если этот АгентИсполнитель уже захватил эту КонсольДиалога, функция возвращается немедленно. Иначе - ожидает освобождения КонсольДиалога.
    * Если другой АгентИсполнитель желает получить КонсольДиалога, сообщение об этом выводится в консоль пользователя. Так пользователь узнает, что есть задание, которое ожидает своей очереди диалога.
    * Чтобы пользователь не запутался, какой команде принадлежит текущий [ДиалогПП], надо в начале диалога выводить исполнителя и тему [ТемаДиалогаПП], но не задание, так как вложенные процедуры могут иметь разные свои [ТемаДиалогаПП].
        * question: Может быть, текст - [ТемаДиалогаПП] надо передавать функции getConsoleWait() сразу, а не отдельно выводить потом на КонсольДиалога?   
* В функции readWait()его поток ожидает освобождения семафора и сообщение передается через текстовый буфер. 
* Он пишет тексты [ДиалогПП]а в КонсольДиалога функцией writeConsole(), а не в общий вывод консоли пользователя. 
* Он закрывает КонсольДиалога функцией closeConsole(). КонсольДиалога должна иметь счетчик открытий для текущего АгентИсполнитель, каждое закрытие его уменьшает. Когда счетчик = 0, КонсольДиалога освобождается и может быть передана следующему ожидающему ее АгентИсполнитель.  

+++обычные сообщения консоли пользователя
* Выводить сообщения на консоль пользователя мимо КонсольДиалога и одновременно с ней может любой АгентИсполнитель. Иначе сообщения от других АгентИсполнитель должны будут ожидать завершения диалога, а он может быть очень долгим. Но сообщения должны помещаться в очередь, чтобы изолировать их источники-потоки и не прерывать друг друга.
    * Эти сообщения можно выводить другим цветом, отличным от цвета текста [ДиалогПП]а. 
* То есть, есть канал вывода в консоль пользователя - для отчета о завершении задачи. И есть КонсольДиалога, для доступа к которой собирается очередь АгентИсполнитель - очередь АгентИсполнитель для КонсольДиалога.

+++разное
КонсольДиалога лучше представить отдельным объектом, хотя проще в Движке реализовать требуемые функции, но объектом - проще отлаживать код.
КонсольДиалога должна будет содержать:
* счетчик сколько раз АгентИсполнитель захватил КонсольДиалога.
* объект АгентИсполнитель, который захватил КонсольДиалога - чтобы отклонять другие попытки захватить КонсольДиалога или записать что-то в нее.
    * или ИдентификаторАгентаИсполнителя, он уникальный и по нему можно получить сам АгентИсполнитель. 
* функции доступа к КонсольДиалога: открыть, закрыть, захватить, освободить, проверить что КонсольДиалога свободна.
* очередь ожидающих АгентИсполнитель.
    * question: какой тип очереди: FIFO или LIFO ?
    
+++[ДиалогПП] с точки зрения пользователя
В простой схеме, пока [ДиалогПП] не завершен, пользователь не сможет ничего другого ввести в консоль пользователя.
Надо чтобы пользователь мог вместо ввода ответа ввести другую команду - Дать другое задание Оператору.
Например, команду Оператору отменить текущее задание, чтобы выйти из [ДиалогПП]а.
Или другое задание Оператору, прямо посреди [ДиалогПП]а.
* То есть обязательно нужно уметь различать и обрабатывать сторонние команды внутри [ДиалогПП]а.
* Для этого нужно явно указать ИдентификаторАгентаИсполнителя в команде, первым словом команды. Если ввод не содержит первым словом ИдентификаторАгентаИсполнителя, то считается что это часть [ДиалогПП]а. Движок должен распознать эти случаи и выполнить новое задание, не прерывая текущий [ДиалогПП].
    * Если ИдентификаторАгентаИсполнителя - "Оператор", то Движок сам подбирает свободного АгентИсполнитель, как при обычной команде. Если ИдентификаторАгентаИсполнителя = существующий АгентИсполнитель, и он свободен, то ему передается это задание. Если АгентИсполнитель занят, то задание передается первому свободному АгентИсполнитель.
    * Если команда - отмена задания, то она передается указанному АгентИсполнитель. То есть, у команд есть класс Управляющие команды, они передаются указанному АгентИсполнитель, а не свободному, как обычные команды.
        * todo: Вот у команд теперь есть классы: Обычные, Управляющие, ... и они по-разному должны обрабатываться Оператором.   
* Если новое задание тоже потребует [ДиалогПП], то оно должно будет ждать, пока закончится текущий [ДиалогПП].
Поэтому такая команда не должна использоваться пользователем как поставщик данных для продолжения текущего [ДиалогПП]а.

Другое решение - использовать отдельное окно диалога на каждый АгентИсполнитель - уже обсуждалось поверхностно и решено было от нее отказаться. Решено иметь 1 консоль и 1 [ДиалогПП] одновременно.



++ Тема Команды

* ШаблоныКоманд
* СемантическаяПроверкаКоманды
* СпособРаспознаванияТипаРегекса
* СопоставлениеКомандыИПроцедуры

+++Система команд
Надо выбрать какую-то область, имеющую практическую ценность, и использовать ее для развития этой системы. Чтобы я понимал, что и зачем я делаю, зачем эти [Команда]ы нужны и что они должны делать, и как выглядеть будут формулировки [Команда].

Вот это самое важное сейчас - определить область применения технологии и собрать материалы для разработки этого представления.

Надо выбрать какую-то хорошо знакомую и востребованную тему. Например, Инвентарь. К нему составить такой список запросов, который бы работал в текстовой консоли, был нагляден и удобен и естественен в использовании.

Но следует отметить, что сами [Команда]ы, исполняемые обычно в такой консоли, малопригодны для этого задания. Секретарь должен понимать, когд программа завершилась успешно, когда с ошибкой. В существующих утилитах командной строки это реализована как попало. Секретарьу нужно четкое стандартное сообщение вроде Программа завершена. А в существующих программах все очень плохо с этим. 
Также, Секретарь должен понимать промежуточный вывод информации в консоли, а это еще менее  стандартизовано.
Секретарьа придется или обучать восприятию, или переписывать все эти [Команда]ы так, чтобы они выводили понятную информацию.
Переписать все это невозможно, поэтому нужно применить какие-то модели абстракции, пропуска непонятной информации. Все как с обычными объяснениями процесса для людей - указывать характерные маркеры - признаки успешного или неуспешного процесса. Признаки состояния процесса. Обучение Секретарьа будет схоже с обучением людей, если всю инфраструктуру для этого восприятия удастся реализовать схоже с человеческой. 

+++1
Надо проработать и описать механизмы выборки команды и исполнения команд.
Чтобы они стали блоками для использования в нужных местах проекта.
Потом надо всю диаграмму этих каналов, списков, очередей, потоков и событий разработать, чтобы она тоже стала скелетом - четко описанной конструкцией.
Это позволит затем дополнить ее другими детальками конструктора, и получить требуемый продукт.

Есть идея развивать Прототип1. Это позволит уже сейчас начать им пользоваться, и нарабатывать Команды и Процедуры и Места.

+++Подстановка Мест в строке исполнения команды
Сегодня мне захотелось опробовать команду Играть Хиты.
Такой команды не было, и Оператор вернул отказ.
Я вручную через БД сделал команду, подобную Открыть Хиты.
То есть, синоним, только без ссылки на прототип.
А вот мне бы хотелось сделать эту команду как Плеер Хиты.
То есть, команда была бы играть Хиты. Регекс был бы играть %Место.
А строка исполнения была бы Плеер %Место.
То есть, Места предлагается искать и в строке исполнения и там подменять их также, как аргументы.
Можно ли это реализовать? 
Не будет ли строка исполнения других команд портиться, если ее часть совпадет с названием какого-то места?

+++Команды для Оператора
[Команда]а Удалить пустые каталоги в %каталог  -  часто мною сейчас используется.
Ее можно реализовать [Процедура]ой или вызываемым приложением.

Но я сейчас рассматриваю способ реализовать ее через скрипт, как последовательность [Команда].
Пока нет контекста КонтекстЗадачи, можно делать это через список пустых каталогов.
Создать список пустых каталогов в %каталог
Удалить элементы списка пустых каталогов
Удалить список пустых каталогов.

Вероятно, список пустых каталогов тут Сущность, причем временная, значимая только внутри КонтекстЗадачи.
Тут вообще надо продумать как пользователь должен работать с этими списками.

+++ Многовариантные Команды
Полиморфизм [Команда]ы.
Характерно, что для завершения работы приложения используется несколько вариантов [Команда]ы. Все они прописаны в коде приложения. Таким образом, приложение можно закрыть любым из описанных в коде слов. Такая многовариантная [Команда]а позволяет пользователю не запоминать формат [Команда]ы, а использовать выражения по их смыслу. Хотя сами эти выражения надо предварительно внести в программу.

+++Шаблон команды
Regex-like sample of voice command template

* (включи*|переключи*) [на] [канал*] $Text *

*   = any text
()  = regex brackets
|   = or
[]  = regex square brackets? Optional element specified.
$Text = item title

Под такой шаблон подходят фразы типа «Эй переключи на Новости». Или «Включи канал Спорт». При этом в переменную $Text будет помещено название канала, который нужно запустить. Все просто!

+++Команды
[Команда]а создается на основе случая использования. Сначала выявляется Use Case, потом для него разрабатывается [Команда]а (название и аргументы [Процедура]ы), [Место]а (как переменные кода), [Алгоритм] [Команда]ы - как собственно тело [Процедура]ы.
[Команда]ы надо соотносить с классами [Команда] для организации использования, и с ПакетЗнаний как происхождение [Команда]ы - чтобы знать, откуда она появилась и как ее восстановить или принести на другой компьютер.

[Команда]ы отличаются от [Процедура] тем, что [Процедура]а - способ реализации [Команда]ы пользователя. А [Команда]а - это сопоставление [Команда]ы пользователя и некоторой [Процедура]ы для достижения требуемого результата.
Чем больше у Оператора [Процедура], тем больше [Команда] в нем можно реализовать.
[Команда]а может использовать только одну [Процедура]у, но [Процедура]а может использовать несколько вложенных [Процедура].

+++Классы команд
[Команда]ы налдо организовать в функциональные классы. Например, [Команда]ы настроек Оператора.
Эти классы обобщают функциональное назначение [Команда].
Эти классы полезны при просмотре общего списка [Команда] Оператора, когда пользователь ищет в них что-то подходящее.
И эти классы, и [Команда]ы вообще, нуждаются в [Команда]ах просмотра этих классов и [Команда] в классе. 
И еще нужны [Команда]ы поиска [Команда] по ключевым словам.
Иначе пользователь заблудится в этой куче [Команда], которые он все равно не в состоянии запомнить все.
Эти классы надо или сразу прицеплять к [Команда]е, или наоборот, классы создавать как папки и прицеплять к ним [Команда]ы. Так проще и универсальнее - [Команда]а может относиться к нескольким классам, с точки зрения пользователя.
КлассКоманды подобен namespace из C#. Он отражает общую тему набора команд. Команды одного класса целесообразно объединять в тематический ПакетЗнаний.

+++Происхождение исполняемых файлов
Исполняемые файлы сторонних производителей используются в [Процедура]ах [Команда].
Для таких программ надо записывать куда-то (наверно, в описание [Процедура]ы или [Команда]ы):
    * Версию продукта, в который входит программа.
    * Название продукта,  в который входит программа.
    * итд
Это нужно для того чтобы при переносе [Команда]ы на другой компьютер можно было легко воспроизвести окружение программы. Это важно, поскольку программы обычно устанавливаются собственным установщиком, и их нельзя распространять вместе с Оператором. Например, Офис.
То есть, [Процедура]а и [Команда]а рассчитаны на некоторое ПО, которое надо установить отдельно от Оператора.

+++Команды внутри [Алгоритм]а процедуры
[Алгоритм] [Процедура]ы представляет собой чат, который идет по сценарию, определяемому [Алгоритм]ом. Но пользователь может такой сценарий прервать совсем, приостановить, отклониться от сценария, или отвлечься на другую деятельность и потом вернуться и продолжить сценарий через некоторое время. Это вроде беседы на некоторую тему.
Так вот, внутри такого сценария пользователь может запросить другие [Команда]ы и сценарии. 
Например, при настройке напоминания пользователь может пожелать выбрать музыкальный файл для напоминания. А для этого потребует вывести имеющиеся файлы, проиграть их, не удовлетвориться ни одним, искать подходящий файл в общей коллекции музыки, и потом добавить его в коллекцию сигналов напоминания, и собственно поставить в напоминание.
Или даже не закончить этот поиск, а отложить его, создать новое напоминание о том что нужно подобрать музыкальный файл для напоминания.
Вот такой вот сложный сценарий получается. Он слишком локальный по ситуации. Его никак нельзя предусмотреть и нет смысла упаковывать в [Алгоритм].
Это требует некоторого особого подхода к исполнению [Процедура] и общей организации программы.
Это все надо переосмыслить.

Такой [Алгоритм] - чат можно попробовать реализовать подобно миссиям в игре Х3. Там пользователь не жестко привязан к [Алгоритм]у. Там [Алгоритм] отслеживает условия-триггеры: вход в определенную область пространства, посадка на станцию, вход в сектор. И соответственно срабатывают назначенные события. Такая машина состояний, сборная из всех начатых миссий. Поэтому, кстати, брать несколько миссий опасно - они наложатся и заглючат. Но там это дизайнеры и тестировщики выявляют такие коллизии. А тут некому выявлять коллизии, да и изменить ничего нельзя в [Алгоритм]е. Тут придется эти срабатывающие триггеры либо по очереди отрабатывать, либо сразу все кучей. Или спрашивать пользователя, к какому [Алгоритм]у это пользовательское действие относится?
    * Тут надо КонтекстЗадачи выявлять - пользователь все еще в этом [Алгоритм]е или уже переключился на что-то другое. По контексту и возбуждать эти триггеры или что там получается.
    
+++1
Команды
У Команд есть такая особенность - результат выполнения Команды нужно задать подобно аргументу.
В этом они отличаются от синтаксиса языков программирования.
Например: Собрать машину(результат) из этих деталей(аргумент1) и болтов(аргумент2)
Результат здесь указывается как абстрактный тип - класс, а не как объект. Но вернуть эта команда должна объект или значение ошибки.
То есть, команда задает класс результата и объекты аргументов.

+++2
Команды
Для Мест и Команд нужны Команды как часть функций Оператора:
- Посмотреть список Мест
- Найти Место %название
- Найти Команду %название
- Добавить Место %название
- Добавить Команду %название
- Удалить Место %название
- Удалить Команду %название

+++3
Для КСВ-файлов нужны работы:
- Собрать несколько ксв-файлов одинакового формата в один большой
- Разбить ксв-файл на Х равных частей построчно.
- Разбить ксв-файл на части размером не более Х кб.
- Разбить ксв-файл на части, содержащие по Х строк каждый.

Еще нужно решить вопрос с кодировками файлов. Хотя для начала можно обойтись одной стандартной кодировкой.
И еще с символами конца строки - они разные в Линуксе и Виндовс.
Можно ли это добавить в Оператор как Команды?

+++Оператор команды
Текст команд набирать долго.
Поэтому я наверно буду использовать Оператор для таких работ, которые требуют много действий.
Где надо открывать приложение, вводить некие данные, проводить поиск, набирать/выбирать/искать Сущности.
Оператор мог бы это сделать быстрее, так как у него есть доступ к АПИ, управляющему контентом.

Но такая работа плохо детерминирована. Только некоторые наиболее частые действия можно таким образом автоматизировать.
И в итоге, работа, например, с Инвентарь, сильно изменится как сценарий, как процесс.
А значит, и сам Инвентарь придется переделывать позже.

Надо записывать сценарии выполняемых мною работ и собирать запросы к Оператору. Хотя Оператор не работает сейчас, но все же запросы надо в него вводить. Чтобы потом собрать их все и статистически выявить необходимые для реализации. 

+++Обрабатывать нераспознанные команды
Надо бы нераспознанные команды обрабатывать сразу на месте, пока пользователь не потерял контекст процесса.
* Либо делать из них синонимы команд или мест.
* Либо регистрировать как новую, не реализованную команду. Для последующей реализации. 
Если это именно команды, а не случайные опечатки. Для этого надо запрашивать пользователя. Непосредственно после ввода команды. И сразу выработать решение по этой команде.
И хорошо бы иметь возможность этот диалог отложить на потом, поскольку не всегда есть время на выяснение всех обстоятельств.
Но этот отложенный диалог все же должен быть проведен - значит, надо о нем напомнить пользователю и сделать это правильно и удобно.

А сейчас эти команды просто пишутся в лог команд. И потом они должны просматриваться и реализовываться отдельно. Но на практике делать это некогда, да и уже непонятно, что имелось в виду и как должно было выполняться. Контекст задачи уже потерян.


