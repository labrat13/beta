++ Концепция Сущностей Мест
[template: ШаблонСтраницыРазделаКонцепции]
Состояние: [В РАЗРАБОТКЕ] - очень отрывочная кучка материалов, пробелы по всем важным вопросам.
* найти в вики еще материалы по Место и добавить сюда
* переработать материалы в связные тексты по главам.
* ответить на вопросы

+++Ссылки раздела
* ГлоссарийОператор




++Общая информация
[Место] - это важная часть концепции Оператор. Обозначает Сущность некоторого Класса.
Пользователь в РИ оперирует Местами и Командами. 
Места упоминаются в Командах в качестве аргументов Процедур.

Сущности обозначаются речью. Как в Инвентаре, у каждой сущности должно быть уникальное имя, или же их указывать придется порядково внутри сущности-группы, или же какие-то абстрактные формы обозначения сущностей. Пока без практики не получается что-то предложить.

++Место как Сущность

Оператор должен хранить список названий [Место] КоллекцияМест, которые используются пользователем как ярлыки. Например, [Место]а Мои проекты, Мои документы.
Для управления КоллекцияМест нужно использовать:
    * набор [Команда] в стиле РИ, хотя возможно, они будут уж слишком сложными для парсинга в РИ.
    * диалоговое окно в стиле ГУИ 
Это список вида: 
название сущности - веб-подобный путь к файлу или каталогу сущности.

* Каждый документ или файл это сущность, с точки зрения Оператора.
* Чтобы Оператор мог давать советы по теме работы, что-то предлагать, нужно чтобы он оперировал сущностями, их классами и метаданными. 
Например, я создаю новый проект, и Оператор сразу сообщает мне, что в проекте полезно применять принцип модульности, и предлагает поискать подходящие модули.
Для софтового проекта это библиотеки и классы из моей коллекции классов. 
Для электронного проекта это модули и блоки из Инвентарь.

Места в Операторе это Сущности. Их нужно представить как объекты соответствующих классов. Для них надо определить и описать свойства и методы.
Вот как Оператор научить работать таким образом с этими [Место]ами?
Как представлять [Место]а как объекты классов, со свойствами и операциями, но не в коде, а наращивая это по ходу работы?
Как и где их хранить?
В Тапп?
Как добавлять и задавать свойства, методы и отношения сущностей?
- вручную можно задавать через некий интерпретируемый язык описания, где скрипты, [Алгоритм]ы, и все вообще будет создавать и дополнять сам Оператор. Ну или пользователь пока Оператор не готов.

* вот надо переименовать - это не [Место]а, а сущности. Что-то вроде ярлыков. Надо подобрать правильное название. Это и приложения и файлы и папки и веб-сайты.
* Есть сущности простые и есть сущности - контейнеры. 
    * Приложение является вроде как контейнером для сущностей - открываемых им файлов. 
    * Папка - контейер, содержащий папки и файлы. 
    * Текстовый файл является контейнером для кусков текста.
* Для сущности можно указать несколько классов. Но пока они не используются. Они должны использоваться при проверке семантической допустимости операции. Это должно делаться внутри [Процедура]ы-из-кода, так как только там известна семантика операции и всякие обстоятельства. Это нельзя сделать при вызове приложения командной строки.
* Можно предложить добавление [Место] через рабочий стол - через гуй пункты в контекстном меню. Там показывается диалог для свойств [Место]а. И так оно добавляется в список [Место] системы РИ. Это позволит быстро вносить в список [Место] новые [Место]а. Хотя не так атмосферно, как через консоль, зато быстро.

* [Место]а могут быть набраны с опечатками. Надо тогда выводить сообщение, если аргумент не удалось опознать и сопоставить [Место]у. Хотя по КонтекстЗадачи это должно быть именно [Место]. Но определить это можно только в [Процедура]е-из-кода.
* Можно предложить автоматически превращать в [Место]а ярлыки с рабочего стола. Но это нецелесообразно. 
    * Не все ярлыки там пригодны для такой обработки. Например, ярлык ворда не содержит пути к исполняемому файлу ворда и его надо добывать вручную, шарясь по папкам в Program Files.
    * Не все ярлыки приложений нужны пользователю для запуска текстом. 
    * Ярлыки не всегда постоянные, чтобы их в качестве [Место] использовать. Есть ярлыки и файлы только для привлечения внимания пользователя - как у меня.
    * Названия в ярлыках не всегда достаточно короткие, чтобы их набирать текстом.
    * Есть еще ярлыки программ в меню пуск, но они тоже не все часто используются. Большая часть этих приложений используется косвенно, через файлы, или вообще не используется. Например, Adobe Acrobat Reader. Просто я так  знаю, что он есть, установлен. Незачем его вносить в качестве [Место]а. Хотя можно использовать в [Процедура]ах открытия файлов pdf.
    * Таким образом, в [Место]а целесообразно оформлять реально инфраструктурные каталоги, сущности, или то что часто используется в текстовых запросах, если они вообще собираются. Приложения, которые используются непосредственно. Например, Инвентарь.
* Можно предложить мои проекты завести в [Место]а. Но вот с ними проблема - они часто не распакованы в папки. Если бы их хранить стабильно, или в коде [Процедура]ы проверять рааспакованность и распаковывать если не распакована, а потом возвращать. И как часто я открываю мои эти проекты? Хотя идея годится для реализации.

++++Проблемы с [Место]ами
* Общая проблема старого образа жизни, описана в теории РИ: пользователь не может запомнить названия всех сегодня используемых [Место]. Сейчас он их видит в меню, на десктопе, да и так помнит по ежедневным своим операциям. А с РИ он не сможет столько много [Место] держать в памяти и должен будет часто пользоваться обзором [Место], подобным системе меню Пуск. Хотя, со временем, он лишние [Место]а забросит, и все нормализуется. 
* Но до тех пор, пока пользователь не привык, эти [Место]а надо как-то показывать, быстро находить, хотя пользователь не помнит их названий.
* Такие же проблемы и с [Процедура]ами. Их тоже надо выводить в списки-меню, разделив по классам. Для этого надо для каждой [Процедура]ы описывать семантику.

+++Тема Динамика Мест
* todo: надо существенно проработать эту тему Динамика Мест - мне нужно, чтобы места вполне заменяли в моих процессах папки и файлы, в том числе, временные.

Места могут быть:
* Неизменяемые, Инфраструктурные - Например, МоиДокументы. Часто относятся к ОС и основным установленным программам, существуют более 6 месяцев.
* Рабочие - Например, папки проектов. Появляются и исчезают, существуют более месяца.
* Временные - Для разных мелких работ, существуют неопределенный срок - могут и годами лежать где-то забытые, но нужные.

Все установленные в Ос программы можно рассматривать как Места инфраструктурные или рабочие.
Все ярлыки на рабочем столе можно рассматривать как Места с неопределенным временем существования. 
Это могут быть и ярлыки программ, и ярлыки временных важных документов.
   
* Для выявления забытых Мест надо хранить для них дату последнего использования, дату создания, класс Места (например, это программа или документ или папка или файл)
* Места, которые не использовались более 6 месяцев, надо предложить пользователю осмотреть и удалить. 
Эту задачу надо добавить в Планировщик Оператора - предлагать еженедельно, как часть системы обслуживания Оператора.
Это аналог поиска неиспользуемых ярлыков на рабочем столе Винды.

* С одной стороны, [Место]а  образуют инфраструктуру, так как они почти не меняются. С другой стороны, [Место]а могут и меняться - исчезать и появляться. И вот это надо отслеживать. Иначе старые сущности будут захламять систему. 
    * Можно предложить для [Место] хранить дату последнего обращения. И предлагать пользователю просмотреть и удалить давно не использовавшиеся [Место]а. Не все [Место]а можно удалить автоматически, и это должен решать пользователь - администратор системы. Но он должен тогда разбираться, что это за [Место]а и в каких [Процедура]ах они участвуют. Чтобы не удалить важное [Место].
    * Вообще, Места как Сущности у меня довольно быстро появляются и исчезают. Обычно, они образуются в процессе работы, хранят некие временные данные, потом эти данные перерабатываются в другие наборы данных, потом упаковываются в архивы и убираются в архив. Такая работа у меня довольно интенсивно происходит, и концепция Мест должна ее хорошо поддерживать. Поэтому надо существенно проработать эту тему Динамика Мест - мне нужно, чтобы места вполне заменяли в моих процессах папки и файлы, в том числе, временные.
* То есть, Места бывают постоянные и динамические, временные. 
    * Постоянные - это, например, папка МоиДокументы. Они образуют инфраструктуру, рабочее окружение.  
    * Временные - это образующиеся в ходе рабочих процессов. Они часто остаются и долго лежат без внимания, представляя собой недоделанную работу. Хотя их нужно доделать и удалить.
* Это разделение не всегда устойчивое. Часто папки и файлы становятся практически постоянными, хотя предполагалось, что они временные. У меня так всегда из-за недоделанных работ - они накапливаются. Но это неправильно, их надо доделывать и убирать. Поэтому такое разделение на инфраструктурные и рабочие Места - полезно.   
* Как Места различать на постоянные и временные? В Тапп я мог бы просто связать постоянные места с узлом Инфраструктура, а временные - с соответствующим узлом Задача (Ну или процесс). И тогда для каждого Места можно было бы сказать, что оно некая часть инфраструктуры Оператора, или оно часть некоего процесса, который был начат, но  не закончен до сих пор. Но это требует внедрения Тапп в Оператор в качестве БД. А Тапп еще не доделан. 
    * У Места есть свойство КлассМеста. В нем можно указать любое количество классов для данного Места. Поэтому можно в нем описать место как Инфраструктурное или как Временное. Этот класс может быть и унаследован, например, если место - коллекция фильмов, то она наверняка должна относиться к классу инфраструктурного места. Хотя это не значит, что она всегда будет доступна и не будет завтра удалена почему-либо. 

+++Файлы и папки как Сущности
Оператор должен описывать как сущности:
* файлы и папки файловой системы
    * архивы-бекапы проектов
    * файлы результаты проекта
    * файлы материалов проекта
    * файлы и папки внутри проекта
* файлы и папки внутри архивов. (Архивов проекта и вообще архивов)
* фильмы, музыку (клипы, альбомы, артистов)
* жанры для всех сущностей
* книги, литературные произведения, документы

У них должно быть:
* имя
* класс Сущности
* описание для пользователя
* связи с другими сущностями

Надо чтобы при восстановлении папки или файла из архива эти метаданные сразу интегрировались в общую систему Сущностей.
Вероятно, нужен Тапп для этой СтруктураСущностей.
При создании архива надо добавлять в него файл описания Сущностей как ЧастичныйСнимокСтруктурыСущностей Тапп.
Но тогда нельзя изменять архив - добавлять или удалять из него файлы и папки. Иначе будет нарушена согласованность описания и файлов архива.

Смысл этого всего в том, чтобы улучшить возможности поиска материалов и результатов проектов. И вообще, любых Сущностей для Оператора.
Нужен универсальный механизм, который можно применить и к проектам также.
Поэтому проекты это только часть предметной области и функциональности для разрабатываемой системы.

+++Синонимы Мест
Для [Место] нужно иметь возможность быстро создавать Синонимы СинонимМеста. Например, МоиДокументы это синоним Мои документы. Только текст другой. Но это не универсальная замена - это собственный, уникальный синоним [Место]а. Иначе будут накладки в других случаях, и все перепутается.
Этот синоним надо создавать быстро, просто ссылкой на основное [Место]о. Но эти ссылки надо отслеживать, чтобы при удалении основного [Место]а, решать, удалить ли и его синонимы.
* С синонимами СинонимМеста есть проблема - при удалении записи [Место]а из БД, надо еще удалять его из синонимов всех схожих записей.
* Потребуется команда Создать синоним места <Название места>
* question: Как хранить СинонимМеста?
    * Можно в отдельной таблице для синонимов мест.
    * Можно отделить Место от его названия, и хранить названия как СинонимМеста отдельно.
    * Можно СинонимМеста создать как Место. В сущности, Место это ярлык для реальной Сущности. Будет несколько разных ярлыков, указывающих на одну и ту же Сущность. 
* question: Как удалять СинонимМеста?
    * Зависит от реализации СинонимМеста. 
* question: Как проверить что СинонимМеста уже существует?
    * Зависит от реализации СинонимМеста.
* question: Как связывать СинонимМеста и [Место]?
    * Зависит от реализации СинонимМеста. 
* todo: Подумать, нужно ли реализовывать эти СинонимМеста? Пока это выглядит излишним.

+++Управление Местами в Операторе
(управление местами через команды Оператору) 
Для управления [Место]ами нужны команды:
* Создать место <Название места>
* Найти место <> / Показать место <>
* Удалить место <>
* Изменить место <> / Отредактировать место <> / Редактировать место <>
Также, потребуются диалоги ввода и изменения свойств [Место].
Также, потребуются наборы свойств [Место] по умолчанию. Для каждого КлассМеста свои наборы свойств по умолчанию.

+++Создание Мест
* Места добавляются в коллекцию мест и в БД. Поскольку места только загружаются из БД, но не выгружаются обратно, то записать новое место надо и в БД и в коллекцию мест одновременно.
* Можно ли перезагрузить коллекцию мест из БД после добавления в БД нового места?
* Нужна будет функция проверки уникальности названия Места - по столбцу синонимов и по столбцу названий мест (если вдруг синонимы не введет пользователь).
* Нужна функция проверки структуры строки описания типа мест
    * Она вроде бы уже есть?
* Нужна общая функция Движка ДобавитьМесто(Место м), которая всю работу делает.
* нужна функция проверки пути к месту.
* todo: Нужна функция автоматического определения типа Места - отложить на потом. 

++++Склонения существительных для диалогов Оператора
В речевой форме:
* И Это Ворд.
* Р Родители Ворда
* Д Дали Ворду яблоко,
* В упрекают Ворда
* Т за бардак, творимый Вордом.
* П Заботятся о Ворде.

++++Автоматическое создание Мест
* Сложность в необходимости указать падежные формы названия места. Автоматически это сделать нельзя сейчас - это должен сделать пользователь, причем он должен уметь образовывать эти формы. Ошибки в этих формах приведут к недоступности [Место] при исполнении [Команда].
* Сложность в определении КлассМеста.

++++Ручное создание Мест
поле 	Значение 		Описание
id	0
title	Браузер
type	Приложение::Веб...
path	C:\Program files...
descr	Программа веб-браузера
syno	браузер, браузера, ...

Замечания:
- Класс сущности места слишком сложная штука для Пользователя. Он постоянно там будет ошибки делать. Поэтому это поле при создании Места надо оставлять пустым, а заполнять потом отдельно, просматривая всю БД Оператора. Либо заполнять автоматически по анализу пути к Месту. Все равно это значение сейчас не используется.
-- Тут нужен набор фиксированных значений и проверка формата выражения - удается ли его распарсить.
-- Данные для автоматического определения можно брать из реестра виндовс - там их немного есть.
- Уникальное имя Сущности - надо проверять эту уникальность при создании Сущности.
- Падежные формы названия Сущности. Они могут содержать пробелы и цифры. Пока нет словаря словоформ, эти формы придется вводить пользователю. И никакой словарь не поможет, если слова составные или нетипичные - в словаре нет склонений для таких слов.

Все это можно представить в виде формы, а можно в виде диалога текстового.

++++Диалог создания Места
Порядок и тексты вопросов надо еще обдумать и изменить.
0) Вы хотите создать новую Сущность. Для прекращения диалога введите  Отмена в ходе диалога.
1) Как кратко но точно назвать Сущность?
(Название/Пусто/Отмена)
- Сущность Название уже существует. Придумайте другое название.
2) Перечислите через запятую падежные формы для Название:
- Имен(Кто?), Род(Кого?), Дат(Кому?), Вин(Кого?), Твор(Кем?), Предл(О ком?)
(Текст/Пусто/Отмена) 
(Или тут лучше многострочный диалог-таблицу словоформ?)
3) Опишите тип сущности Название, или пропустите этот шаг, поскольку это слишком сложно.
(Текст/Пусто/Отмена)
4) Как можно кратко описать эту Сущность Название, чтобы узнать ее из тысячи?
(Пусто/Текст/Отмена)
5) Какой путь к файлу или веб-адрес использовать для доступа к Название?   
- Файл не существует. Вы уверены в правильности адреса?
(Да/Нет/Пусто/Отмена)
6) Сущность Название успешно добавлена.
Конец.

+++Редактирование Мест
* todo: написать текст тут

++++Диалог редактирования Места
* todo: Разработать диалог тут

+++Удаление Места
* todo: написать текст тут

+++Проверка использования Места
* todo: написать текст тут

+++Хранение Мест
* todo: написать текст тут

+++Импорт Мест из ПакетЗнаний
Если ПакетЗнаний содержит несколько [Место], то их придется импортировать в Оператор.
Также надо будет импортировать или согласовать и КлассМеста для этих [Место]. А это может быть сложно, если ДеревоКлассовМест у источника ПакетЗнаний отличается от текущего ДеревоКлассовМест Оператора.
* question: Следует ли распространять ДеревоКлассовМест как ПакетЗнаний как обновление Оператора?
    * Например, если ПакетЗнаний представляет мой Инвентарь, он должен будет добавить много КлассМеста - прямо целое собственное ДеревоКлассовМест. Нужно будет выполнить слияние этих деревьев в Оператор. А как при этом разрешать конфликты (например, одинаковые названия классов) - я вообще не представляю себе сейчас.
        * а зачем нужны эти КлассМеста в Оператор? Чтобы использовать названия предметов в командах? Так команды эти относятся к Инвентарь и сами могут определять КлассМеста через Инвентарь. Теоретически. Наверно.

* todo: написать текст тут

+++Распознавание мест в команде
См. РаспознаваниеМест

++Классы Мест как Классы сущностей
См. СписокМестИТиповМест

Вообще надо составить сейчас список таких сущностей, чтобы определиться с их типами.
Это могут быть файлы, папки, файлы-приложения, сетевые адреса серверов, адреса в неких каталогах вроде WMI, итд. 
И еще надо иметь возможность определить их тип для семантической проверки аргументов операции.

Это класс сущности - [Место]а. [Место]о используется в [Процедура]ах как аргумент. И для него нужно установить класс, чтобы проверять соответствие типов аргументов и [Процедура]ы. 
Место определяется пользователем, значит и класс [Место]а следует определять пользователем.

Сейчас классы [Место] можно определить из ПримерыЗапросов.
Классы [Место] можно разделить на  сущности и контейнеры сущностей. В концепции Инвентарь Предмет - сущность. Категория - контейнер предметов. Контейнер - контейнер предметов. Инвентарь - контейнер для предметов, категорий, контейнеров. И класс должен быть соответственно обозначен записью. 
Для С# формата это: Инвентарь<Предмет, Категория, Контейнер>, Категория<Предмет>, Контейнер<Предмет>. Для папок это Каталог<Каталог, Файл>. Для текстовых файлов это Текстовый_файл<Текст>.
Распарсив это выражение, система узнает, что сущность класса Текст можно добавить в сущность-контейнер класса текстовый файл.
Это выражение представляет отношение агрегации сущностей.
Еще хорошо бы иметь отношение абстракции, вроде Файл -->Текстовый_Файл-->яхзчто, но тут уже, похоже, нужен Тапп, чтобы все это хранить и разбирать.
Где хранить эти записи? Можно в описании [Место]. Именно в поле тип сущности. 
* См также СписокМестИТиповМест
* Надо поместить эти запросы из ПримерыЗапросов в файл экселя, выделить в них аргументы и разработать названия [Процедура], регексы, и другие свойства [Процедура]. Чтобы потом быстро создать эти [Процедура]ы и получить таким образом ограниченно работоспособную версию программы.
* ФорматЗаписиТипаМеста - 30.07.2016 22:20 Разработан формат для записи текстом дерева классов для [Место]а. Надо проверить и оптимизировать его реализацию.

++++Классы сущностей
Классы сущностей нужны не только [Место]ам, но и [Процедура]ам. Но сейчас о [Место]ах.
Например Документ::Журнал::МоделистКонструктор  это класс для журналов Моделист-конструктор в ХранилищеДокументов.

При обращении к хранилищу за документом можно получить также и его класс и соответственно искать или управлять документами.

Оператор не может хранить много [Место], поэтому сущности должны храниться в каталогах ХранилищеХххх.
А вот сами каталоги уже можно считать [Место]ами-контейнерами сущностей, поскольку их немного.
И Оператор мог бы работать с сущностями, находящимися в этих каталогах.

Класс журнала:  Журнал<Статья> : МоделистКонструктор<СтатьяМодель>
Журнал это контейнер для статей.
Статьи бывают разных видов (классов). Журнал может содержать статьи разных классов.

Эти типы и их иерархию, всю эту классификацию нужно держать в Справочнике.
А объекты этих классов в соответствующем Хранилище.

Создание таких каталогов и системы классов, определение операций с ними, общая оптимизация использования этих типов были бы общественно полезными результатами проекта.
Особенно если эти каталоги будут наполнены реальным содержимым.
Но такого содержимого у меня нет. Не могу же я использовать нелицензированный контент. 

++++Роли Файлов и других Сущностей
Проблема с файлами и вообще Сущностями в том, что их свойства определяются их интерпретацией в каждом конкретном случае.
Их ролью в этом случае.
Это может быть решено через иерархию подклассов.
Для каждой роли можно разработать подкласс файла, который будет содержать нужные свойства.
Но это не всегда правильно.
Иногда это не подкласс файла, а просто некая роль, в ней оказывается файл или другой объект.
Роль это класс-обертка для разных классов. В ООП роль и класс объединяются разработчиком на этапе проектирования. 
Он использует не Сущность саму по себе, а Сущность в некоторой роли.
Хотя эта тема должна уже быть изучена в теории ООП и языков программирования.
Но как отдельная тема она мне пока не попадалась.

Эти роли тоже можно свести в иерархии классов?
Например, ЭлементСписка. 
Интерпретация одного класса в другой, если они не связаны явно отношением абстракции (наследования).

++++Набор параметров [Место] по умолчанию
КлассМеста должен еще предоставлять для создаваемых новых [Место] наборы свойств [Место] по умолчанию. 
Для каждого КлассМеста свои наборы свойств по умолчанию.
Как их хранить и как их назначать - должен определить создатель КлассМеста при создании КлассМеста.

+++Отношение агрегации

Обозначается как последовательность, путь, вложенность контейнеров записывается через точку:
Журнал Моделист-конструктор.1996.№1 - пример по имени объектов
Журнал.ГодоваяПодшивка.Экземпляр (или Выпуск?) - пример по имени классов

В записи классов я сейчас использую : для обозначения отношения классификации и между классами и между классом и объектом.
Это неправильно. Отношение между классами это отношение классификации. А отношение между классом и объектом - отношение инстантиации.
- Отношение агрегации типично обозначается точкой.
- Отношение клаассификации типично обозначается :
- как обозначать отношение инстантиации? Я вот как раз его использую сейчас в РИ: Журнал<Статья> : МоделистКонструктор<СтатьяМодель>
Мне тогда надо парсер классов переделывать. Хорошо, что он пока не развит, и это достаточно просто сделать. В этом польза первых прототипов.

Но из-за того, что я долго это вообще не разделял, мне трудно отделить отношение классов от отношений класс-объект. И я их путаю при описании класса сущности.
А неподготовленный пользователь вообще не сможет ничего сделать правильно. И превратит всю систему в кучу мусора.

Можно предложить разработать структуру классов заранее и предлагать пользователю ее использовать.
- а кто будет ее разрабатывать? Академия наук?
- а кто будет ее использовать и где? Я, конечно. Кто же еще.
- а какой мне от этого толк? Меньше работы при использовании и обслуживании всего этого объема информации.

Получится этакая глобальная БД. А где взять ресурсы на ее содержание?

Библиотека полезна тогда, когда она используется. А я пока не использую ничего из нее.

Я не могу собирать иерархию классов без хранилищ объектов этих классов. 
Сначала надо сделать и наполнить хранилища сущностей, а потом уже придумывать и совершенствовать структуру классов этих сущностей.
Но это надо делать, а не тянуть резину. Время идет, а результатов нет. 

+++Отношение абстракции
* todo: написать текст тут

+++Система классов Оператора
Для Оператора и других моих программ надо создать систему классов Сущностей и Методов.
Включающую в себя:
* Реестр типов.
* Импорт типов из реестра Виндовс, включая CLSID.
* Быстрое определение аргумента-контейнера.
* Быстрое определение типа аргумента в методе команды Оператора.
    * arg.HasType("file");
    * arg.SubtypeOf("file");
    * arg.SupertypeOf("file"); 
* Функции добавления, удаления, просмотра этих типов и их связей.
* 29.04.2017 15:40:49 Предлагается эту систему типов хранить как часть РегистрХранилищ. Так она будет общедоступной для всех моих приложений на локальном компьютере.
    * Это не совсем правильно. Система типов это совершенно другая сущность, чем РегистрХранилищ. Она должна храниться где-то рядом, подобным же образом. Но нельзя объединять ее с РегистрХранилищ. Это должна быть отдельная служба. Хотя физически ее можно обслуживать той же dll, но лучше отдельной - проще вносить изменения в движок. Она может быть доступна по тому же уникальному имени и вообще-то являться отдельным специальным Хранилищем.
* Предлагается  эту тему и РегистрХранилищ вынести отсюда и из других проектов в отдельный проект. Так с ним будет проще работать из разных проектов.
    * Сейчас пока все это лежит в разных проектах по месту применения, чтобы быстрее развивалось и накапливало материал.
* ДеревоКлассовМест могло бы представлять систему классов для Оператор. Пока хотя бы для [Место].
* Тапп хорошо подходит для таких применений. Но он не закончен.  

+++Запись текстом Класса Мест
См.  ФорматЗаписиТипаМеста

+++Автоматическое создание Класса Мест
* Пока нельзя автоматически создать КлассМеста, хотя тема не изучена.
* Можно пока предложить класс "Требуется определить класс" для пометки Сущностей неизвестного класса. А определить класс позже должен будет пользователь, как часть работы по развитию Оператора.
* Можно предложить импортировать класс для данной Сущности из внешних источников. Но пока нет таких источников у меня.

++++Импорт классов из реестра
* Была идея вытащить из реестра винды типы сущностей и применить здесь. Оказалось, там ничего такого полезного нет - все полезное делает ShellExecute автоматически, для него там эти данные и лежат. И все это сильно усложнено, месяц надо разбираться. Ну его нафиг. 

+++Ручное создание Класса Мест
* todo: написать текст тут

++++Определение класса места
* Проблема с КлассМеста - пользователь не сможет сам все определить и назначить. Можно эти КлассМеста импортировать из внешних справочников. Но это потом - сейчас я сам должен эти КлассМеста определить, и как они должны обрабатываться. Наверно, Тапп в этом пригодится. Еще пригодится наблюдение за запросами пользователя, и их автоматический анализ по известной семантике выполняемых [Процедура]. Но для [Процедура] тогда надо описывать семантику так же, как я КлассМеста описываю. Но я слишком мало работаю с компьютером, чтобы такой материал наблюдений быстро и много накопить.

++++Диалог создания Класса Мест
* todo: Разработать диалог тут

+++Хранение классов мест
* Вероятно, в некоторой таблице классов мест БД. Хотя в таблицу такое количество данных вряд ли поместится.
* Вероятно, в индивидуальном файле XML.
* Можно в Тапп, но он пока не закончен.
* todo: написать текст тут

+++Импорт классов мест из ПакетЗнаний
* Так же, как и импорт самих [Место]
* todo: написать текст тут

+++Редактирование классов мест
* todo: написать текст тут

++++Диалог редактирования класса Мест
* todo: Разработать диалог тут

+++Удаление класса мест
КлассМеста это ценная семантическая единица, которая может пригодиться в будущем.
Сначала надо убедиться, что данный КлассМеста нигде не используется. Иначе будут испорчены использующие его Места и дочерние КлассМеста.
Это удаление должно быть обосновано пользователем. Нежелательно удалять КлассМеста просто на основе его неиспользования.
КлассМеста обычно входит в иерархию классов, поэтому удалить нужно целую ветвь этой иерархии, а не отдельно взятый класс. Поэтому удалять КлассМеста можно только через ДеревоКлассовМест.
* Вывод: КлассМеста можно удалить только если:
    * Решение обосновано существенными причинами
    * И Нет использующих его Мест
    * И Нет производных от него классов. 

+++Проверка использования класса мест
* todo: написать текст тут

+++Управление Классами Мест в Операторе
(управление классами мест через команды Оператору)
Для управления КлассМеста нужны команды:
* Создать класс места <Название класса места>
* Найти класс <> / Показать класс <> (возможно, конфликтует с Показать класс места <название места>)
* Удалить класс <>
* Изменить класс <> / Отредактировать класс <> / Редактировать класс <>
* ...
Также, потребуются диалоги ввода и изменения свойств КлассМеста.
Также, потребуются наборы свойств [Место] по умолчанию. Для каждого КлассМеста свои наборы свойств по умолчанию.

Но я пока плохо себе представляю, как эти сегодняшние КлассМеста создавать и связывать через команды Оператора.
Они же не сами по себе, они объединены в ДеревоКлассовМест и используются согласованно со всеми остальными штуками в Операторе. 
    * Их иногда придется задавать при создании [Место], это неудобно.
    * Надо видеть все ДеревоКлассовМест, чтобы правильно работать с КлассМеста. 
    * Любое использование КлассМеста - это сложно и требует высокой квалификации пользователя Оператор. Ему придется работать с ДеревоКлассовМест. И это плохо, ошибки разрушат систему Оператора.
 Автоматизировать же это определение КлассМеста для [Место] тоже пока не придумывается, хотя очень желательно.


++Дерево Классов Мест
Это иерархия наследования КлассМеста.
Нужна пользователю для любой работы с КлассМеста.
Нужна Оператору при определении КлассМеста как класс аргумента внутри [Процедура].
* todo: добавить текст тут

+++Построение дерева классов мест
* todo: написать текст тут

+++Хранение дерева классов мест
* todo: написать текст тут

+++Использование дерева классов мест
* todo: написать текст тут

++Другое
+++Нужны классификации объектов
Для Оператора нужны классификации объектов. Ими надо заниматься.
Но нельзя, потому что надо их где-то хранить.
Объекты, классы - в Тапп. Самый правильный способ.
Но Тапп не готов и теория тоже.
Проект Справочник Органайзера?

+++Доступ к внутренним Сущностям Оператора
Еще вопрос: А можно ли представить сущности архитектуры Оператора как Места?
Например, Коллекция Мест Оператора можно ли представить как Место?
Надо это обдумать.
* question: Для чего это нужно?


++Материалы
+++Классификация сущностей
Итак, Оператор работает не просто с объектами, а с сущностями определенного типа. 
Каждая роль (место в [Алгоритм]е, обозначается обычно переменной) может быть описана требованиями к классу объекта, к содержимому объекта.
Это может быть не просто класс вроде int, а специальный субкласс, для которого объекты отбираются особенным образом, и который возможно нигде более в системе не применяется. 
Кроме этого конкретного куска [Алгоритм]а.
То есть, это такой кастинг объектов для этого класса. Не каждый подойдет.

Нужно обеспечить хранение объектов с указанием их класса. 
И обеспечить хранение классов и связей между ними.

+++Классы в РИ
Взято из ТемаМеста 18.03.2017 0:03:11 - может и тут пригодится?
Это классы [Задача]? Или классы сущностей? Или [Задача]и это namespace?
* Класс это сущность, описывается существительным. Класс содержит сущности - переменные и функции-процедуры. Переменные класса представляют свойства сущности, представленной классом.
* Это не совсем то что нужно.
[Задача]а должна быть представлена [Алгоритм]ом. [Алгоритм] содержит сущности и действия. Но концепция класса здесь не подходит.
* В то же время, [Алгоритм] является контейнером для сущностей и действий. Вот как бы их, класс и [Алгоритм], скрестить?
* Теоретически, [Алгоритм] поддерживает и абстракцию, и инкапсуляцию, и полиморфизм.
* Абстракция [Алгоритм]а: он состоит из абстрактных [Алгоритм]ов. Вроде [Алгоритм]а абстрактной функции класса, который состоит из абстрактных типов данных и абстрактных функций других классов.
* Надо бы эту тему по [Алгоритм]ам поставить в общий план разработок.

++++Типы объектов в Хранилищах
В Хранилищах надо хранить также типы объектов, чтобы эти АПИ-пользователи могли их использовать.
Без типов сущностей все эти объекты в Хранилище - неведомые инопланетные артефакты. 
Оператор не может их различить и работает с ними в меру своих знаний. 
То есть, делает только то, что требует скрипт или пользователь.

Классу объекта сопоставляются действия. Они определяют и возможность выполнения действий, и конкретную реализацию действия.
Но это долгая тема. 
 
++++Классы сущностей
Классы сущностей нужны не только [Место]ам, но и [Процедура]ам.
Например Документ::Журнал::МоделистКонструктор  это класс для журналов Моделист-конструктор в ХранилищеДокументов.

При обращении к хранилищу за документом можно получить также и его класс и соответственно искать или управлять документами.

Оператор не может хранить много [Место], поэтому сущности должны храниться в каталогах ХранилищеХххх.
А вот сами каталоги уже можно считать [Место]ами-контейнерами сущностей, поскольку их немного.
И Оператор мог бы работать с сущностями, находящимися в этих каталогах.

Класс журнала:  Журнал<Статья> : МоделистКонструктор<СтатьяМодель>
Журнал это контейнер для статей.
Статьи бывают разных видов (классов). Журнал может содержать статьи разных классов.

Эти типы и их иерархию, всю эту классификацию нужно держать в Справочнике.
А объекты этих классов в соответствующем Хранилище.

Создание таких каталогов и системы классов, определение операций с ними, общая оптимизация использования этих типов были бы общественно полезными результатами проекта.
Особенно если эти каталоги будут наполнены реальным содержимым.
Но такого содержимого у меня нет. Не могу же я использовать нелицензированный контент. 


++++Отношение агрегации
Как путь, вложенность контейнеров записывается через точку:
Журнал Моделист-конструктор.1996.№1 - пример по имени объектов
Журнал.ГодоваяПодшивка.Экземпляр (или Выпуск?) - пример по имени классов

В записи классов я сейчас использую : для обозначения отношения классификации и между классами и между классом и объектом.
Это неправильно. Отношение между классами это отношение классификации. А отношение между классом и объектом - отношение инстантиации.
- Отношение агрегации типично обозначается точкой.
- Отношение клаассификации типично обозначается :
- как обозначать отношение инстантиации? Я вот как раз его использую сейчас в РИ: Журнал<Статья> : МоделистКонструктор<СтатьяМодель>
Мне тогда надо парсер классов переделывать. Хорошо, что он пока не развит, и это достаточно просто сделать. В этом польза первых прототипов.

Но из-за того, что я долго это вообще не разделял, мне трудно отделить отношение классов от отношений класс-объект. И я их путаю при описании класса сущности.
А неподготовленный пользователь вообще не сможет ничего сделать правильно. И превратит всю систему в кучу мусора.

Можно предложить разработать структуру классов заранее и предлагать пользователю ее использовать.
- а кто будет ее разрабатывать? Академия наук?
- а кто будет ее использовать и где? Я, конечно. Кто же еще.
- а какой мне от этого толк? Меньше работы при использовании и обслуживании всего этого объема информации.

Получится этакая глобальная БД. А где взять ресурсы на ее содержание?

Библиотека полезна тогда, когда она используется. А я пока не использую ничего из нее.

Я не могу собирать иерархию классов без хранилищ объектов этих классов. 
Сначала надо сделать и наполнить хранилища сущностей, а потом уже придумывать и совершенствовать структуру классов этих сущностей.
Но это надо делать, а не тянуть резину. Время идет, а результатов нет. 



+++Сущности из файлов и папок
* Сущности - файлы и папки хорошо бы создавать на лету из собственно файлов и папок файловой системы. В тот момент, когда они нужны. Но вот папки коллекций вроде МояМузыка лучше забивать особо и сразу. Вручную или предустановленными - это надо решить, как удобно будет.
    * Вручную - значит [Место] создается пользователем с вводом всех свойств  как для любого [Место]а.
    * Предустановленным - [Место]о уже существует, заранее описано и создано, но его надо прицепить к папке в операционной системе. Это надо предложить пользователю на этапе развертывания и настройки программы. И пользователь мог бы это сопоставление отложить или совсем отключить это [Место]о. Если он не будет вести проекты, зачем ему [Место]о МоиПроекты?
        * Тут еще надо учесть, что эти папки не всегда соответствуют стандартным для ОС - в стандартных все криво сделано, и пользователи или предпочитают собственные папки, как у меня, или вообще держат коллекции в сети.
    * Это все будет ясно, когда к этим файлам и папкам будут идти запросы.
        * Но для этих запросов надо реализовать эти файлы и папки, или притворяться что они реализованы.
* Можно данные файлов и папок хранить в метаданных файла (NTFS только). Это замедляет поиск [Место], зато не надо синхронизировать БД при изменениях файловой системы. 
* Этих файлов и папок так много, что их не запомнить. Это обычная проблема РИ.
    * Тут можно попробовать использовать абстракции и нечеткие указания Сущностей.

+++Работа с сущностями
 При работе с файлами есть проблемы, не позволяющие сделать эту работу столь же интенсивной и простой, как с ГУИ.
- надо как-то указывать имена файлов в операциях.
  - имена файлов часто содержат лишнюю информацию - дату, номер версии и прочие свойства. Такие имена удобно просматривать в списке файлов. Но неудобно вводить вручную. Особенно это в Линуксе.  
  - вообще вся работа с файлами плохо приспособлена для интенсивного использования. Тут все так, словно это раз в месяц происходит, и времени на это выделяется с огромным запасом.
- при РИ имена файлов должны быть короткими и семантически рациональными.
- вот типа задача: в папке есть куча файлов, мне надо переместить три из них в другую папку.
  - в ГУи я их открываю в Проводнике, отмечаю и переношу в требуемую папку.
  - в РИ я должен их именами описать и при этом могут быть ошибки.
    - можно отметить их как-либо. Я сначала должен эти файлы видеть, просматривать каталог.
По памяти не получится - слишком много файлов.
По общим названиям - вроде Мой любимый плейлист - там немного будет таких сущностей, которые я могу запомнить. Хотя я смогу тогда помнить только их имена, а не в какой папке они лежат. Это тоже память, только другая. Неизвестно, какая проще.    
Сейчас все это разнообразие и файловое богатство основано на том, что пользователю показываются списки файлов, и он с ними работает. Эти списки ему заменяют память, он на [Место]е ориентируется. Каталоги используются как классификаторы сущностей. Поэтому и работа идет интенсивно.
РИ в этом плане плохо пригоден. Он сведет все к списку из 7 элементов.
- Можно совместить РИ как [Команда]ы и ГУИ для просмотра. Это сложно, но надо обдумать.
- Надо разделить [Задача]и, для которых пригоден РИ и [Задача]и, для которых нужен ГУИ.
  Их не нужно смешивать. 
РИ хорош для [Задача] работающих с одиночными именованными объектами. 
ГУИ хорош для работы со множеством объектов.
- Память на самом деле используется для запоминания [Задача], соответствующих им папок, состояния [Задача]и. И вообще, для хранения знаний об общей организации информации на компьютере, и в остальном мире. Вот надо бы эту общую организацию осмотреть и оптимизировать.
  - как ее можно оптимизировать? 
    - Можно применить стандартные методики оптимизации, только их надо найти и переложить на эту область.
    - для начала, я быстро осмотрел существующие проекты и собрал стандартную структуру каталога проекта. Теперь все новые проекты должны будут иметь единую систему папок и их не надо будет помнить для каждого проекта. Это должно сэкономить память немного.
      - надо перевести существующие проекты на эту новую схему. Но тогда все уже созданные ссылки-ярлыки попортятся, и их тоже надо будет переделывать. 
  - как ее можно осмотреть? Это ведь отдельная тема для работы. С собственной теорией и собственными заметками.
 
 
 