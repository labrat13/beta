++ Концепция Многозадачности Оператора
[template: ШаблонСтраницыРазделаКонцепции]
Состояние: [В РАЗРАБОТКЕ]

+++Ссылки раздела
* ГлоссарийОператор


+++Содержание раздела



+++Материалы
++ Тема Многозадачность
Оператор получается многопоточным. Из-за необходимости реагировать на внешние события, ну и потому, что пользователь не хочет ждать, когда единственное задание выполнится.
Многопоточность означает, что данные придется передавать между компонентами Оператора через буферы - очереди, а внутри компонента в бесконечном цикле будет работать собственный поток - обработчик таких сообщений.
Такое устройство системы требует более тщательного проектирования и отладки, так как выявить ошибки взаимодействия потоков обычно очень трудно, и вся система в результате работает нестабильно и непредсказуемо.

+++1
Несмотря на многопоточность, оператор сейчас может отрабатывать только одно окно консоли.
Соответственно, только одну процедуру может запустить пользователь.
Хотя автоматические процедуры могут работать одновременно с остальными.
Но все они разделяют одно окно консоли. И все их сообщения на консоли будут вперемешку отображаться.
Поэтому автоматические процедуры не должны требовать ввода или вывода на консоль.
Особенно ожидать ввода пользователя - он не понимает, что он сейчас должен вводить, кому отвечать.
Чтобы все это разрулить правильно, надо для каждого задания (сеанса работы пользователя) показывать собственное окно консоли.
Но сейчас у меня окно только одно. 
Для мелких заданий можно совмещать окно консоли. Например, плеер запустить и управлять его работой.
А вот для более насыщенных - надо заводить отдельную консоль.
Вот это сейчас надо на одноконсольном варианте Оператор опробовать.

+++2
В однозадачной схеме, старой, только одна команда могла выполняться одновременно. 
Пока она выполняется, остальые ждут в очереди команд.
- Команды Break и Pause останавливают исполнение этого одного потока исполнения.

Но у меня тут много разных каналов внешних событий.
Они не могут ждать, пока пользовательская задача завершится.
И наоборот пользователь не хочет ждать, когда Оператор освободится от обработки событий.
- Можно подбор процедуры для команды сделать одним потоком, а исполнять найденную процедуру - другим потоком.
Основной поток находит процедуру и отдает ее одному из рабочих потоков - Исполнителей.
  - не получится. Процедуры еще и сами могут отказаться от исполнения. 
    Там все сложно. Процедуры могут переопределить команду и перезапустить для нее поиск процедур. 
    Нужен один поток на поиск процедуры для команды и ее исполнение.
    Значит, исполнение команды делается одним потоком целиком.
  - к БД и данным придется монопольный доступ потока делать. И для лога тоже.
- а можно ли другую схему?
  Выборку процедур для команды делать одним потоком движка. 
  Он обрабатывает команду, собирая сущности. 
  Из БД получает список процедур и сортирует его по весам.
  А исполнение процедур из этого списка делает уже поток Исполнитель.
  Тогда БД используется одним потоком Движка.
  А процедуры всей их кучей исполняет поток Исполнитель.
  А если процедура переопределяет команду, новую команду просто отправляют в Движок заново, 
  и все снова происходит по этому же алгоритму.
  - это разгружает таблицу процедур БД. А еще есть файлы, места. 
    И есть команды, которые используют данные из БД. Например: Покажи места.
    Тут поток-Исполнитель должен извлечь места из БД и составить список и вывести на консоль пользователю.
    И никак тут не отвертишься от многопоточного доступа к БД.
    А если он все равно нужен, то зачем лишние сложности - надо делать как лучше и проще.


Тогда и лог нужен многозадачный. Как в Тапп, только вместо агентов - задания.
Задания заключать в транзакции. Откатывать задания по транзакциям.
Если их можно откатить - для этого нужно каждой процедуре сопоставлять процедуру обратную.
- Это слишком сложно пока. Отложим все это на будущее. Отложено на ТретийПрототипКонсолиРИ.
- пока Лог будет простым последовательным списком сообщений.
- Тут есть идея о сходстве Оператор и Тапп в архитектуре. 
  Можно бы подумать, как реализовать Оператор на Тапп. Чтобы использовать преимущества Тапп и функционал Оператора.
  Но пока и Тапп и Оператор - один большой эксперимент. Этим можно заняться позже, когда будет больше опыта.
  И когда будет готов и пригоден для работы и Тапп и Оператор.

+++Исполнители с именами
todo: Эту тему с исполнителями надо проработать. Она хорошо (кажется) вписывается в  общую концепцию Оператор.
    * Перенести тексты по теме на страницу ТемаАгентИсполнитель и переработать для внесения в концепцию Оператора.
    * Эта идея влияет на другие решения в разных темах. Надо поместить ссылки на идею и следствия принятых архитектурных решений в эти другие темы. 

Чтобы выводить диалоги разных заданий на одну консоль, нужно присвоить их исполнителям имена (текстовый идентификатор-аббревиатура).
Тогда пользователь не будет путать диалоги вперемешку.

Например:
Открыть сайт ххх и играть музыку

Иван: Открываю сайт ххх.ком
Федор: Запускаю плеер.
Иван: что дальше делать с сайтом?
Федор: Увеличить яркость экрана?

Как пользователь на это будет отвечать?

Иван, закрой сайт.
Федор, играть свежую музыку.

Или?

Иван, скачай все музыкальные файлы по ссылкам на странице.
Федор, собери эти файлы в плейлист и играй на плеере.
----
1. Это слишком сложно. Два задания должны взаимодействовать, тут нужен ИИ.
Который будет и за Ивана, и за Федора делать работу.
2. Алгоритм работы тут задан, но он непродуман. Тут надо:
-найти на странице все ссылки на музыкальные файлы.
-найти место для размещения скачиваемых файлов
-скачать музыкальные файлы по ссылкам
-создать новый плейлист и добавить в него скачанные файлы
-запустить плеер с этим плейлистом.
Это мог бы делать один исполнитель, но в команде указаны два. И они должны координировать свою работу.
Федор должен ждать, пока иван скачает новый файл, и после этого добавить его в плейлист.
И наверно сразу же играть на плеере.
Получается, нужен ИИ, который разберет два алгоритма заданий Ивана и Федора, создаст из них конвейер, новый алгоритм.

------------
В целом, пример неправильный. Пока только один диалог может вестись в консоли одновременно.
Так как для диалога надо хранить контекст задания.  
 
Имена в качестве ИД исполнителей - удачное решение. 
Их легко выделить из текстов команд.
Они обозначают сущности - исполнителей.
-То есть, теперь в команде еще надо выявлять имена исполнителей.
- а если указанный исполнитель занят, то как быть?
  - сообщать что указанный исполнитель занят и предлагать другого. 
    Например: Иван, включи плеер. - Иван занят, Федор свободен. - Федор, включи плеер.
- массива из 16 исполнителей будет достаточно?
  - Только пока в скриптовых процедурах команд используется только один исполнитель.
    Но со временем и они займут всех исполнителей работой.
- Удобно контролировать загруженность системы:
Покажи исполнителей. или Что делают исполнители?
Иван: свободен
Федор: свободен
Вадим: Качать торрент ххх

Пока имена исполнителей не были нужны, так как ранее в Операторе предполагалось только один исполнитель, только одно задание одновременно.
Хотя, вот есть задания из канала событий, и их придется как-то реализовывать одновременно с работой пользователя.
Возможно, следует сделать пул исполнителей заданий. И тогда присвоить им имена.
Но эта концепция пока набросок отрывочный. Ее надо проработать, развить идею.
Имена исполнителей - лучше, чем идентификаторы заданий. Человекоподобнее. 
Идентификаторы заданий еще придумать надо, и по ним не поймешь, о чем они.
Имена исполнителей тоже ничего не говорят о задании, но их проще запомнить и они привычны для такого использования.
Исполнителя можно командой спросить что он делает:
Иван, что ты делаешь? -  Иван: <Текст команды:> Включить плеер.
Иван, прекрати работу. 