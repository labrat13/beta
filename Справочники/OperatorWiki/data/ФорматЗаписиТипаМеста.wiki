++ Формат Записи Типа Места
[template: ШаблонСтраницыРазделаКонцепции]
Состояние: [В РАЗРАБОТКЕ]

+++Ссылки раздела
* ГлоссарийОператор

Формат записи типа [Место]а для абстракции и агрегации вместе.

* Класс - это обозначение здесь названия типа [Место]а.

+++Сложный пример выражения
Это выражение описывает тип некоторого места как принадлежащего нескольким классам, с отношениями абстракции и агрегации. Для восприятия будет удобнее, если сложные части выражения поместить в конце, а простые в начале.
* Класс;Класс::Класс;Класс::Класс<Класс::Класс, Класс, Класс::Класс>;

+++отношение абстракции
* Класс::Класс - это отношение абстракции. Первый член выражения это надкласс, второй - подкласс в отношении абстракции. Надкласс в выражении может не указываться.

+++отношение агрегации
* Класс  - простой тип, не контейнер. Имя класса может состоять из нескольких слов, содержать пробелы.
* Имя класса состоит из букв,-+_= и цифр. Не должно содержать ,:;<> как символов формата разметки. 
* Класс<Класс> - тип-контейнер для сущностей другого типа.
* Класс<Класс, Класс, Класс> - тип - контейнер для сущностей нескольких типов
* символы группы < и > могут отделяться пробелами с одной или двух сторон.
* Вложенные группы не допускаются.
* элементы группы разделяются запятыми. До и после запятых могут быть пробелы.

+++Несколько применений сущности
* Элементы разделяются точкой с запятой. После последнего элемента точка с запятой не обязательна.
* Класс; Класс<Класс, Класс>;Класс

+++Комбинация абстракции и агрегации
* Класс::Класс; Класс::Класс<Класс::Класс, Класс, Класс::Класс>;

+++Варианты записи выражения с пробелами и без
* Имя класса состоит из букв, пробелов, знаков -+_= и цифр. Не должно содержать ,:;<> как символов формата разметки. 
* Имя класса может состоять из нескольких слов, содержать пробелы.
* выражение :: может отделяться пробелами с одной или обеих сторон.
* Элементы разделяются точкой с запятой. После последнего элемента точка с запятой не обязательна.
* символы группы < и > могут отделяться пробелами с одной или двух сторон.
* Вложенные группы не допускаются.
* элементы группы разделяются запятыми. До и после запятых могут быть пробелы.
* Класс:: Класс;Класс ::Класс < Класс::Класс,Класс , Класс :: Класс >


+++Порядок парсинга выражения:
Это приблизительный набросок, его надо проверить и оптимизировать.
Предлагается обрабатывать выражение как дерево, каждый элемент на каждой стадии отдельной функцией.
* разделяем на элементы по ;
* у всех элементов удаляем пробелы с начала и конца Trim()
* Для каждого элемента отделяем группы по < и >. Получаем класс-контейнер и список классов-сущностей. 
* У всех частей  удаляем пробелы с начала и конца Trim()
* Список классов-сущностей делим по ,. Получаем классы-сущности
* У всех частей  удаляем пробелы с начала и конца Trim()
* Каждый элемент выражения отделяем родительский класс по ::
* У всех частей  удаляем пробелы с начала и конца Trim() 


+++Как это будет использоваться?
* Сначала надо создать структуру для хранения этих распарсенных типов.
Для каждого класса надо хранить один или более надкласс абстракции, и ноль или более подклассов агрегации. Итого это два списка того же класса объектов.
* потом надо прочитать это выражение в это дерево классов. И хорошо бы и обратно записывать дерево классов в строку текста.
* теперь у нас есть для некоторого [Место]а его ТипМеста (класс). Он нужен для определения пригодности аргумента. Но только для конкретного применения в некоторой [Процедура]е, а не вообще. Поэтому строить общее супердерево классов не имеет смысла, пока нет Тапп. Ну разве что для любопытства. Или отладки сложных проблем с типами.
* Нам просто надо проверить, может ли некоторый материал быть помещен в некоторый контейнер.
Может ли для некоторого типа аргумента выполняться указанная операция.
* Типы аргументов - не [Место] придется определять по контексту операции. 
Для таких аргументов надо как-то получить класс и дерево классов. 
Класс можно прописать в коде при его определении для аргумента. 
А где брать дерево классов? Его надо где-то хранить и как-то оттуда получать.
Можно сразу завести его в то же хранилище, что и [Место]а. 
Или можно дерево классов отделить от [Место] и хранить в каталоге классов, в этом каталоге классов хранить все деревья классов. А для [Место]а в поле Класс указать название соответствующего класса. 
Хотя это слишком разнесено будет, есть риск потерять понимание связи [Место]а и класса. 
Зато легко назначать синонимы для [Место] - не надо заново собирать эту запись дерева классов. 
С другой стороны, это дерево классов привязано к КонтекстЗадачи, а не универсально.
* В общем, тут надо еще разрабатывать тему.

++Материалы  