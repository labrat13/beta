++ Устройство Консоли Оператора Версия Июнь 2020
* версия от 28.06.2020 04:35 
* Сейчас это сырая куча идей, а я хочу четкую концепцию с красивыми диаграммами! И экспортировать ее как отдельный документ.
* Многозадачная КонсольОператора, подходит для одно- и многозадачной версии Оператора.
* Эта консоль сложнее, чем сам механизм исполнения команд. Его придется делать долго и внимательно.
* Возможно, такая организация Оператора окажется слишком тяжелой для однопроцессорного компьютера ноутбука.
Это надо проверить практически.
* см. СредстваСинхронизацииПотоков.
* см. ЗаметкаМногопоточныйОператор
* см. [//УстройствоКонсолиОператораВерсияИюнь2020/ConsoleDialogClass] - класс кода Диалога
* см. [//УстройствоКонсолиОператораВерсияИюнь2020/ConsoleMessageClass] - класс сообщения Консоли 
* Задачи
    * выполнить намеченные задачи
    * переработать главы документа 
    * СобратьПримерыИспользованияЗаголовкаОкна
    * РазработатьМеханизмОценкиИОтображенияРазмераОчередиСообщений

+++Общее описание архитектуры Оператора
* Оператор делится (пока) на модули: КонсольОператора и ДвижокОператора.
* КонсольОператора обслуживает GUI-окно приложения Оператор. Она выводит информацию и принимает команды пользователя и события операционной системы. Она же пишет логи: ЛогДиалога, ЛогОператора.
* ДвижокОператора выполняет собственно бизнес-логику Оператора.


+++Окно Консоли
* Прототип - См. [rel://files/Консоль Оператора.doc] 

[rel://files/ConsoleForm.PNG]

Цифрами на рисунках обозначены функциональные области:
1 – ввод диалога пользователя
2 – вывод диалога пользователю
3 – Лог событий Оператора

Области 1 и 2 можно объединить, как это сделано в cmd.exe. Но это требует разработки.

++++Область 1 - Ввод диалога пользователя
* Содержит текстбокс текста сообщения и кнопку передачи сообщения.
* Введенный текст вписывается в файл лога Диалога так,  что должен образоваться полный диалог, и было понятно, где вывод и где ввод.

* Тут надо визуально послать сигнал пользователю, когда диалог требует от пользователя ввода данных. Можно выключать и включать контролы области 1, подсвечивать их неким заметным цветом, мигать заголовком окна, издавать некоторый звук.
    * В терминале эту роль выполняет мигающий курсор в конце текста. А как это реализовать в ГУИ-окне?
    * Если окно консоли свернуто, можно мигать заголовком окна на таскбаре.
    * todo: А если окно развернуто, как показать что программа ожидает ввод пользователя? 

* Если в текстбоксе нет текста, нажатие кнопки Send игнорируется? Или нет? Но как  тогда вводить пустую строку, если кнопка при этом игнорируется? Наверно, надо не игнорировать пустую строку, значит, не проверять на пустую строку. Тупо отсылать все из текстбокса.
* После успешной отсылки текстбокс должен очищаться.
* Тут есть удобства, которые нарушают концепцию РечевойИнтерфейс. И они удобные, но - нарушают. Надо решить, стоит ли их реализовывать и на каком этапе проекта.
    * Можно применить комбобокс вместо текстбокса. А в комбобоксе запоминать предыдущие введенные строки. Так немного удобнее в сложных случаях. Хранить их в отдельном файле или в Настройках Оператора.
    * В текстбокс нужны операции вставки в выбранную позицию, выделения, перетаскивания файлов. Но это позже, на этапе улучшений прототипа.   

++++Область 2 - Вывод диалога пользователя
Вывод диалога – текстбокс только для чтения. 
Окно представить контролом - текстбоксом только для чтения. С поддержкой цвета и разных шрифтов, и возможно, форматирования вроде таблиц. (todo: насколько это полезно?)
Вывод дублируется в файл лога Диалога.
Текст дублировать в файл лога событий Оператора, и выводить тут конец этого файла.
При прокрутке показывать содержимое файла лога, а не копить все сообщения в памяти контрола.
То есть, контрол лишь отображает файл лога как виртуальный документ.
* Если в контроле Область2 более 1000 строк, то  после добавления удаляются первые 300 строк. Так контрол не сожрет всю память процесса.

++++Область 3 - Лог Оператора
Окно лога (3) выводит сообщения о событиях Оператора.
- о произошедших внешних событиях
- о добавлении диалога в очередь диалогов
- о завершении диалога и изъятии его из очереди диалогов
- о ходе внутренних процессов Оператора
- о запуске и завершении Команд и Процедур.

Вывод немедленный, независимо от состояния диалога и консоли.
Окно представить контролом - текстбоксом только для чтения. С поддержкой цвета и разных шрифтов, и возможно, форматирования вроде таблиц. (todo: насколько это полезно?)
Текст дублировать в файл лога событий Оператора, и выводить тут конец этого файла.
При прокрутке показывать содержимое файла лога, а не копить все сообщения в памяти контрола.
То есть, контрол лишь отображает файл лога как виртуальный документ. 
* Если в контроле Область3 более 1000 строк, то  после добавления удаляются первые 300 строк. Так контрол не сожрет всю память процесса.

++++Область 4 - сведения о ресурсах компьютера
* должна отображать сведения о загруженности компьютера. 
Так как из консоли пользователю не видна загрузка компьютера.
* Но пока на рисунках не предусмотрена, так как не является минимально необходимой.

++++Заголовок окна Консоли Оператора
* возможно, пригодится возможность изменения названия окна Консоли Оператора каким-либо потоком Движка.
    * todo: Я не знаю, как это можно использовать? Надо СобратьПримерыИспользованияЗаголовкаОкна.
* Можно реализовать это через сообщение для Лога Консоли, чтобы не добавлять для этого отдельный канал событий. Заодно это событие будет в Лог добавлено. Нужен просто специальный код типа сообщения для этого.
* Там еще и прогресс-бар работы можно отображать, в виндовс 7 - только я не знаю, зачем.
* И по такой же схеме отображать текст в строке состояния окна. 

+++Сообщения
* см. [//УстройствоКонсолиОператораВерсияИюнь2020/ConsoleMessageClass] - класс сообщения Консоли
* Сообщения формируются вызывающим потоком (ПотокИсполнитель Процедуры или некоторый другой поток).
* Один и тот же формат Сообщения Консоли применяется для Области 2 и Области 3.
* Сообщение лога должно содержать таймштамп события.
* Сообщение лога должно содержать тип события, для поддержки возможности разбора лога впоследствии.
* Сообщения выводятся одновременно в Xml-файл лога и в RichTextBox контрол в Области 2 или в Области 3. Поэтому они должны быть форматированы соответственно в двух форматах: XML и RTF.
* Сообщения содержат текст с разными цветами, и возможно, с разными шрифтами, и возможно, с символами форматирования: маркерами списков, итп. Хотя это уже излишества.
* Из-за того, что сообщение лога содержит разные куски форматированного текста, все сообщение надо собрать из таких кусков. Эти куски до сборки из них сообщения должны храниться в списке внутри объекта сообщения.
    * Собирать сообщение должен вызывающий поток, а не принимающий поток, как обычно это делается. Поскольку у принимающего потока много работы, ему некогда форматировать сообщения от десятка вызывающих потоков одновременно.
* Жизненный цикл сообщения:
    * Вызывающий поток создает объект СообщениеКонсоли, добавляет в него все части сообщения, различающиеся цветом или шрифтом, затем выполняет композицию сообщения, эта операция формирует две строки: для XML и для RTF, и удаляет ненужный теперь список частей сообщения. Это нужно, чтобы сообщение занимало меньше памяти. Затем объект сообщения передается соответствующей функции Лога Оператора или Диалога, которая монопольно добавляет сообщение в конец соответствующей очереди сообщений. 
    * Поток-обработчик сообщений - ПотокОчередейКонсоли - в правильный момент монопольно выбирает сообщения из очереди сообщений, сразу все, пачкой, записывает их в соответствующий файл лога, и передает их пачкой для записи в соответствующий контрол формы КонсольОператора. ПотокОкнаКонсоли, обслуживающий форму, добавляет записи в контрол и возвращает управление ПотокОчередейКонсоли. Который переходит к обработке следующей очереди сообщений, и далее, по своему алгоритму.
    * Объекты СообщениеКонсоли уничтожаются где-то в ПотокОчередейКонсоли, неявно, так как после удаления объектов из очереди сообщений нигде не остается ссылок на них. Однако сборку мусора лучше проводить явно. 
        * done: СборкаМусораМногопоточныхПриложений 

+++Модель потоков Консоли
См. [rel://files/diaSynThread.JPG]
* Для Области 1 всю работу выполнять может ПотокОкнаКонсоли. Как реакцию на нажатие кнопки Send.
* Для Областей 2 и 3 я сначала хотел завести отдельные потоки, которые бы ожидали появления сообщений в своих очередях и потом обрабатывали бы их. Но потом я решил их объединить. Так меньше кода писать, и все равно всю реальную работу делает ПотокОкнаКонсоли: он пишет в контролы формы; он пишет в файлы ЛогДиалога, ЛогОператора; он также обслуживает таймер часов и события, приходящие через сообщения окну: события питания, дисковых томов, итп.
Он перерисовывает форму и все такое прочее. Это самый загруженный поток в консоли.
* В итоге было решено завести один поток ПотокОчередейКонсоли для обслуживания очередей сообщений.
* Итак, мы используем один поток ПотокОкнаКонсоли, один поток реакции на события ПотокОчередейКонсоли, дежурящий на WaitAny[3] от 3 каналов: EventLogOut, EventConsoleOut, EventConsoleInWaiting - сигнал ожидания ввода с Консоли.
    * Значит, ПотокОчередейКонсоли будет запускаться по любому из этих 3 каналов событий, и очереди в основном будут пустыми. И никаких пачек сообщений для их групповой обработки в очередях не накопится?
        * Этот поток запустит ДелегатПередачиСообщений, который долго будет исполняться. И за это время может накопиться много сообщений в обеих очередях. Так что пачек сообщений для их групповой обработки можно ожидать.
        * А еще надо как-то отображать на форме размер очередей сообщений для отладки. Или выводить их в ЛогОператора при превышении некоторого предела? todo: Тут надо РазработатьМеханизмОценкиИОтображенияРазмераОчередиСообщений. Это будет полезно при эксплуатации прототипа на реальных задачах с высокой нагрузкой на процессор и диск.    

++++Область 1
* ввод Консоли.  
* Эту область обслуживает ПотокОкнаКонсоли: по нажатию кнопки он читает из текстбокса данные в межпоточный БуферConsoleIn и устанавливает флаг события разрешения чтения ввода EventConsoleIn. Если есть внешний поток ожидающий на этом событии ввод, то он извлекает данные из БуферConsoleIn и продолжает свою работу. А событие сразу автоматически сбрасывается.
* Введенный текст нужно вписать в файл лога Диалога так,  что должен образоваться полный диалог, и было понятно, где вывод и где ввод.
* Однако, пока сторонний поток не ожидает ввода, пользователь не может отправить никакую команду. Пользователь не может прервать процесс работы.
    * Но это можно изменить: перехватывать клавиши Break на уровне окна Консоли; Диалог принадлежит либо ПотокДиспетчер, который всегда ожидает ввода пользователя, либо ПотокИсполнитель, который должен минимально использовать Диалог по времени. Тут надо опробовать всю систему в сборе, чтобы знать эти слабые места.
* Нужно послать сигнал пользователю, что программа ожидает ввод данных.
    * Поток, ожидающий ввода, должен послать потоку ГУИ сигнал об этом, до того, как заснет на ожидании ответа. 
    
++++Область 2
* Вывод Консоли.
* Сообщение от внешнего потока ПотокИсполнитель или ПотокДиспетчер монопольно добавляется в ОчередьСообщенийКонсоли. На этой очереди дежурит ПотокОчередейКонсоли. Он собирает все сообщения из очереди и отправляет через ДелегатПередачиСообщений в ПотокОкнаКонсоли. Там эти сообщения добавляются в файл ЛогКонсоли и в контрол Область2.
* Если в контроле Область2 более 1000 строк, то  после добавления удаляются первые 300 строк. Так контрол не сожрет всю память процесса.

++++Область 3
* Вывод Лога.
* Сообщение от внешнего потока ПотокИсполнитель или ПотокДиспетчер монопольно добавляется в ОчередьСообщенийЛога. На этой очереди дежурит ПотокОчередейКонсоли. Он собирает все сообщения из очереди и отправляет через ДелегатПередачиСообщений в ПотокОкнаКонсоли. Там эти сообщения добавляются в файл ЛогОператора и в контрол Область3.
* Если в контроле Область3 более 1000 строк, то после добавления удаляются первые 300 строк. Так контрол не сожрет всю память процесса.

++++Поток окна Консоли
* Этот поток создается при запуске приложения как единственный поток GUI-приложения.
И уже на этом этапе ему нужен вывод в ЛогОператора, чтобы записывать сообщеия об ошибках этапа запуска системы.
Следовательно, все прочие операции записи в ЛогОператора тоже возлагаются на этот поток.
* Этот поток должен запустить другие потоки КонсольОператора и затем запустить Движок Оператора.
* Этот поток получает через ДелегатПередачиСообщений две пачки сообщений Консоли: сообщения для Лога (Области 3) и сообщения для Вывода (Области 2).
Эти пачки могут быть пустыми. Еще он получает сигнал (флаг или ивент), что надо включить область 1 и привлечь внимание пользователя для ввода новых данных.

++++Поток очередей Консоли
* Этот поток создается потоком ПотокОкнаКонсоли при инициализации, как часть инфраструктуры Консоли.
* Этот поток уничтожается потоком ПотокОкнаКонсоли при завершении работы окна Консоли.
*  

++++ДелегатПередачиСообщений
* Это функция вида void myConsoleDelegate(ConsoleMessage[] OutMsgs, ConsoleMessage[] LogMsgs, bool inputWaiting);
    * он должен внести сообщения OutMsgs в контрол Область 2 и файл ЛогКонсоли,
    * он должен внести сообщения LogMsgs в контрол Область 3 и файл ЛогОператора,
    * если inputWaiting установлен, то:
        * он должен помигать окном, если оно свернуто или на заднем плане.
        * он должен переключить контролы Область 1 чтобы пользователь обратил внимание и начал ввод данных.
        * он должен воспроизвести короткий звук для привлечения внимания пользователя. Если это разрешено в Настройки Консоли Оператора. 
* Если в контроле Область2 или Область3 более 1000 строк, то  после добавления новых строк надо удалить первые 300 строк. Так контрол не сожрет всю память процесса.
* Этот делегат вызывается из ПотокОчередейКонсоли, который остается ждать, пока ПотокОкнаКонсоли исполнит весь код делегата и сопутствующие ему вызовы. Это может быть долго, и в делегате следует выполнять операции асинхронно, по возможности. Особенно файловые операции.
    * И пока делегат работает, окно не сможет обрабатывать другие оконные события? Я не знаю, надо проверить это. 
    *   

+++Модель потоков Движка
* см. ЗаметкаМногопоточныйОператор - todo: добавить в концепцию сюда и привести к общему виду и терминологии.

++++Поток-Исполнитель
* Всю работу в Процедуре Команды выполняет ПотокИсполнитель. 

++++Поток-Диспетчер
* Это основной поток Движка, механизма исполнения команд. Он принимает команды от пользователя через Консоль, выбирает ПотокИсполнитель, обрабатывает результат исполнения команды и управляет всеми ПотокИсполнитель.  

+++Диалог
Диалог это ввод и вывод пользователя.
Поскольку у нас система имитирует Речевой интерфейс, диалог на всю систему может быть только один. И только один какой-то поток может владеть им в каждый момент времени.

Изначально Диалог принадлежит Оператору, чтобы пользователь мог вводить Команды и видеть их результат исполнения.
Но когда Процедуре нужно внимание Пользователя, она запрашивает Диалог и получает его монопольно, и владеет им некоторое время, пока не вернет Диалог или не завершится.

Поскольку диалог один на всех, то он переключается между Оператором и Процедурой текущей исполняемой Команды.
Следовательно, пока Процедура владеет Диалогом, пользователь не может запустить другую Команду.
* пользователю может потребоваться в процессе Диалога Процедуры узнать некие данные,  для получения которых нужно запустить другую Команду. Поэтому ему надо иметь возможность как-то отложить текущую Процедуру, когда он ведет Диалог в ней.  
* чтобы пользователь мог отложить или прервать Диалог Процедуры, нужны служебные команды управления Диалогом:
    * Отмена – прерывает текущую Процедуру и освобождает Диалог. 
    * Отложить – откладывает диалог и выходит в Оператор. Диалог остается отложенным, поток–Исполнитель Процедуры висит в ожидании получения Диалога, первым в очереди на Диалог. Как только текущий Диалог освобождается, первый поток в очереди ожидания Диалога получает Диалог и продолжает с места остановки.
        * Следовательно, все новые события, запускающие Команду, исполнение которой создает ПотокИсполнитель,  если ему требуется Диалог, поток добавляется в *конец!* очереди на Диалог. Чтобы для Пользователя исполнение отложенного Диалога возобновилось с прерванного места, а не как попало! И полуисполненная процедура не была забыта в памяти.
Это можно реализовать только в многопоточном Операторе. В однопоточном можно только отменить (прервать) Процедуру, чтобы задать новую Команду.

В многопоточном Операторе будет много потоков ПотокИсполнитель, и Диалог (или запрос на Диалог) должен иметь ссылку на ПотокИсполнитель, название Исполнителя, название исполняемой Команды, и еще какие-то свойства.

++++Общий ход 
См. [rel://files/dataPath.JPG]

* ПотокИсполнитель получает объект Диалога от ПотокДиспетчер вызовом функции Движка startDialog(...); если Диалог уже занят, ПотокИсполнитель ждет - спит внутри этой функции.
    * Для этого ПотокИсполнитель должен внести данные о Диалоге: название диалога, ияхз что еще.
        * todo: какие данные диалога надо указать при открытии Диалога?
        * ид ПотокИсполнитель, чтобы другие потоки не могли использовать Диалог, а ПотокДиспетчер знал, какой ПотокИсполнитель использует КонсольОператора в данный момент.
    * Эти данные о Диалоге нужно добавить *в конец* ОчередьДиалога, чтобы ПотокДиспетчер выбрал очередной ПотокИсполнитель, который получит Диалог. Вернее, доступ к КонсольОператора для взаимодействия с пользователем.
    * А еще, ПотокДиспетчер может позволить пользователю самому выбрать задачу, с которой он будет вести диалог. Или он может выбирать по приоритету задачи - какая важнее и должна скорее получить Диалог. Или в какой Диалог длится меньше и она будет быстрее отработана пользователем. Эти данные можно хранить в БД в записи о процедуре. Хотя, тут многое зависит от текущей ситуации.   
* Далее ПотокИсполнитель использует функции объекта Диалога для ввода и вывода сообщений Диалога согласно алгоритма Процедуры. 
* Наконец, ПотокИсполнитель вызывает функцию Движка finishDialog(...) чтобы завершить диалог и передать его следующему потоку, ожидающему в ОчередьДиалога. Или ПотокДиспетчер, если нет более Диалогов в ОчередьДиалога.
* Диалог в итоге должен вернуться к ПотокДиспетчер, который собственно и принимает Команды от пользователя, запуская на исполнение новые Процедуры.
* Вот все хорошо. Но могут быть проблемы:
    * А) ПотокИсполнитель повторно вызывает функцию Движка startDialog(...), не закрыв предыдущий Диалог.
    * Б) ПотокИсполнитель повторно вызывает функцию Движка finishDialog(...), не открыв новый Диалог.
    * В) ПотокИсполнитель не освободил Диалог, но завершился из-за ошибки, выбросившей исключение.
    * Г) ПотокИсполнитель закрыл Диалог но продолжает его использовать.
    * Д) ПотокИсполнитель не освободил Диалог, но заснул на некотором (WaitHandle) ожидании события.  

Пример кода:
ConsoleDialog d = Engine.startDialog(...); // поток ждет, когда ему дадут диалог как доступ к консоли
... //делает работу
d.Write("какой-то вывод в консоль");//выводит текст в консоль
string title = d.Read("Введите название");//пример вопроса диалога
... //делает работу
Engine.finishDialog(); //поток освобождает диалог
d = null; //диалог более не используется, но тут надо убедиться, что сам Диалог не поврежден.
... //делает работу
Engine.Log.AddMessage(""); //запись об окончании процедуры в глобальный Лог Оператора.
//конец кода

++++Реализация Диалога
Рассмотрим варианты реализации Диалога:
А) 
* На стороне ПотокИсполнитель собирается struct с данными Диалога и отсылается в Engine.Session.startDialog(...), и в этой функции поток засыпает в ожидании Диалога. 
* Объект Диалога всегда существует в единственном экземпляре, создается внутри ПотокДиспетчер, перед передачей очередному ПотокИсполнитель в него копируются данные для Диалога из struct.
* После получения Диалога ПотокИсполнитель просыпается, получает ссылку на объект диалога, и далее, согласно алгоритму исполняемой им Процедуры, вызывает из объекта Диалога нужные функции. Диалог содержит все функции для этого.
* В конце диалога ПотокИсполнитель вызывает функцию объекта Диалога finishDialog() и... у него остается действующая ссылка на глобальный объект Диалога, которую он должен бы приравнять к null. 
    * Но разработчик Процедуры может забыть об этом, не обнулить ссылку, и продолжить использовать эту ссылку на Диалог. И никак этот доступ у потока не отобрать.
    * Или можно этот объект Диалога уничтожить в Engine.Session.finishDialog() и тогда все ссылки на него недействительны и приведут к выбросу исключений. Которые будут общего типа и их никак не отловить сопоставленно Диалогу.
* Вывод: это вариант не очень хорош.  

Б) 
* На стороне ПотокИсполнитель создается объект ОберткаДиалога, заполняется данными Диалога и передается в Engine.Session.startDialog(...), внутри которой поток засыпает в ожидании Диалога.
* ПотокДиспетчер добавляет этот объект ОберткаДиалога в свою ОчередьДиалога, где могут ожидать своего времени множество таких объектов ОберткаДиалога от разных ПотокИсполнитель. Когда данный Диалог выбран для исполнения, в него вписывается ссылка на глобальный объект Диалога, который реально содержит функции для работы Диалога.  
* После получения Диалога ПотокИсполнитель просыпается, использует свою ссылку на объект ОберткаДиалога, и далее, согласно алгоритму исполняемой им Процедуры, вызывает из объекта ОберткаДиалога нужные функции. ОберткаДиалога содержит все функции для этого.
* В конце диалога ПотокИсполнитель вызывает функцию объекта ОберткаДиалога finishDialog() и... у него остается действующая ссылка на объект ОберткаДиалога, которую он должен уничтожить. Но если он этого не сделает - у него все равно нет доступа к Диалогу, так как ссылка на объект Диалога должна уже быть обнулена в коде finishDialog().
И без этой ссылки обращения к ОберткаДиалога должны вызывать исключения "Незаконное использование Диалога". Ну или что-то похожее. Так как легко проверить, что ссылка на объект Диалога = null. 
* В этом варианте управление получше, чем в А. Исключения можно правильно обработать и подать.

++++Как привязать Диалог к потоку?
* объект Диалога выдается ПотокИсполнитель от ПотокДиспетчер, остальные потоки не должны его использовать, пока он не будет освобожден потоком-владельцем.
* но ПотокИсполнитель может не освободить Диалог:
А) завершиться по исключению в результате ошибки.
Б) заснуть в WaitForSingleObject()
    * Это из-за разработчика Процедуры. Если он неправильно спроектировал Процедуру, то поток надолго заснет и утащит с собой Диалог, до своего пробуждения. Которого может не быть никогда. 
* todo: Как узнать, что ПотокИсполнитель завершился? Он нормально должен отработать свою Процедуру, вернуть ее результат к ПотокДиспетчер и убраться в ПулИсполнителей, где и спать далее. А завершиться он может либо при завершении работы Движка, либо не-нормально. Как об этом узнать?
* ПотокДиспетчер может отвязать Диалог от ПотокИсполнитель и забрать его себе?
    * сначала надо завершить или отменить Процедуру этого ПотокИсполнитель, иначе будут исключения из-за недоступного Диалога. 
* А другие ПотокИсполнитель при входе в Диалог - что?
    А) ожидают получения Диалога - ставятся в очередь, если еще не в ней. 
        * это невозможно! 
    Б) игнорируются молча.
        * значит, эта ошибка пройдет незамеченной пользователем. Это недопустимо.
    В) выбрасывается исключение "Незаконное использование Диалога".
        * Ошибка будет замечена пользователем. Кривой алгоритм Процедуры будет прерван исключением. Все правильно.
* Рассмотрим варианты:
    * До получения объекта Диалога ПотокИсполнитель никак не может его использовать.
    * одновременно два ПотокИсполнитель не должны иметь доступ к Диалогу. Но это может случиться, если ссылка на Диалог не была обнулена. Один ПотокИсполнитель владеет, а другие - имеют работающую ссылку на объект Диалога. Тут можно просто использовать идентификатор потока-владельца Диалога в самом объекте Диалога, чтобы отсекать такие случаи. 
    * После освобождения Диалога ссылка на объект Диалога должна быть обнулена и поток не сможет использовать ее. Он выбросит исключение и завершится. 

++++Класс Диалога
* см. [//УстройствоКонсолиОператораВерсияИюнь2020/ConsoleDialogClass] - класс кода Диалога
* поля:
    * ИД потока-владельца Диалога
    * Название Диалога
    * Ивент, на котором спит поток в ожидании Диалога.
* функции:
    * конструктор объекта
    * ConsoleOut(...)
    * ConsoleIn(...)
    * эти функции надо взять из старого кода движка - там есть полный набор со всеми фишками.
    * ToString() с информацией для просмотра в отладчике. 

++++Реализация ввода через Диалог
* ПотокИсполнитель входит в функцию Dialog.ConsoleIn()
* устанавливает ивент Событие ожидания ввода, чтобы консоль отработала его и привлекла внимание пользователя.
* засыпает и ожидает освобождения на событии ввода от пользователя - когда пользователь введет текст и нажмет кнопку Send.
* читает межпоточный буфер с текстом сообщения - копирует его себе?
* выходит из функции Dialog.ConsoleIn() с текстом сообщения.

+++Проблемы с событиями с диалогами

Пример перекрывающихся диалогов:
- Поступило Событие1
- вывод в лог: Начат диалог по Событие1
...
- поступило Событие2
- вывод в лог: ожидание диалога по Событие2. Диалог помещен в очередь диалогов как №1
...
- вывод в лог: закончен диалог по Событие1
- вывод в лог: Начат диалог по Событие2
...
- вывод в лог: закончен диалог по Событие2
...

Событие обычно приводит к выполнению какой-либо команды.
На каждое выполнение команды должен создаваться (или браться из пула) поток-Исполнитель. Некоторые команды требуют диалога с пользователем.
Только один диалог возможен в один момент времени. Остальные потоки с диалогами должны ждать в очереди диалогов, пока консоль освободится. Тогда диалоги могут ожидать внимания пользователя.
* Значит, если в архитектуре есть обработка событий, то должна быть многопоточность, и никак иначе.
* А если однопоточная архитектура, то она должна быть без событий. И тогда монополия на диалог не нужна.
* Однопоточную схему можно делать сейчас как прототип с Гуем для простого переноса кода движка, без крупных переделок.
* а сразу многопоточную систему делать слишком сложно?
* todo: диалоги отрабатываются в порядке возникновения. Или как-то ими управлять можно?
    * как оценить сложность диалога? Или важность? Тогда можно было бы планировать их очередность обработки?
    * можно предложить пользователю выбрать, если диалогов в очереди более 1? Или тупо подавать в порядке очереди?
    * могут ли возникать диалоги, критичные ко времени реакции пользователя?
    * очевидно, нужен опыт реальной работы с очередью диалогов.

+++Логи Оператора и СеансОператора
* см. ЗаметкаПодсистемаЛога
* Из-за такого количества и объема логов потребуется много файлов лога для сеанса Оператора. Ими надо управлять: и файлами лога и сеансами Оператора. Их надо где-то хранить.
* Сеанс лога надо перезапускать каждые сутки, так как иначе он будет бесконечным! Комп же не выключается, только спит!
* Короче, ведение и просмотр лога - проблема! Как ее решить - не знаю пока!
* Пока ничего нет, соберем сеансовые логи - файлы с датой вместо имени. Пока все просто. А потом - будем разрабатывать всю систему логов. 
    * todo: записать в план работ Задачу разработки системы логов.
* todo: Как связать контрол Области3 и файл лога? Чтобы контрол читал контент из файла и прокручивал такой большой файл?
    * Прямых способов нет. Хотя проблема довольно общая. Просто я логами вообще не занимался серьезно.
    * 1. можно выгрузить содержимое контрола в файл сразу после добавления. Так как лог записывается блоками. целыми кусками.
        * в событии контрола TextChanged перезаписать файл лога.
    * 2. Если в контроле более 1000 строк, то выгрузить 70% строк в файл лога, закрыть его и создать новый файл лога. В него вывести остаток строк лога и затем работать с ним.
        * Но это не позволит промотать лог в самое начало.
    * можно расковырять приложение Lister из TotalCommander или найти код в интернете для отображения больших файлов.
        * писать свой контрол - плохая идея. Он нужен уже сейчас, а его отлаживать надо месяц работы! 
    * можно попробовать как в Тапп: лог разбивать на файлы, а просматривать его также кусочками через общий менеджер Лога. Но все это надо разрабатывать, все это пока только идеи.
    
