++ Концепция Каналы Событий
[template: ШаблонСтраницыРазделаКонцепции]
Состояние: [В РАЗРАБОТКЕ] - первичное наполнение и создание структуры текста
Задачи: рассортировать материалы по разделам, затем переработать разделы в связное единообразное представление.

+++Ссылки раздела
* ГлоссарийОператор


Оператор в первой версии просто выполнял команды.
В текущей проектируемой версии Оператор должен реагировать на события.
Для Оператор нужно реализовать сравнительно полноценное наблюдение за обстановкой.
Нужно завести в него внешние события.

Надо завести основные события к компьютеру в целом. И к пользователю компьютера - вот к этой связке человек-машина.
Надо реализовать это как стандартизованный канал событий, чтобы потом легко расширять набор событий. Например, заводить внешние события (температуру или освещенность) через USB-адаптер.


Для этого потребуется получать извещения о событиях:
* секунды от часов
* события подключения и отключения дисковых томов
* события старта и завершения процессов
* события открытия и закрытия, активизации окон программ
* нажатия клавиш
* события питания
* события электронной почты ?
* события доступности сетевых подключений
* и другие...


Канал событий позволил бы гибко настраивать реакцию Оператора на внешние события: Заряд батареи, подключение флешки, часы, итд. Не жестко, в коде программы, а мягко - пользователь прицеплял бы для каждого события последовательность [Команда], выполнив которые, обеспечивалась бы реакция Оператора.
Это такая система рефлексов, пока что поддерживаемая пользователем. 
Оператор пока не может сам этим управлять. 
Хотя было бы неплохо его научить самостоятельному управлению рефлексами.

В каналы событий будут отправляться события от оборудования, пользователя, итд.
Поскольку эти события в чужом контексте потока, их надо буферировать в очереди сообщений.
На каждый канал нужна собственная очередь.
Оператор должен обрабатывать события, когда они есть, по принципу карусели. А если нет никаких - то простаивать.
События ввода от пользователя - тоже канал событий. Они обрабатываются своим обработчиком, это долго.
Есть события оборудования, питания.
Есть канал событий секунд. Он мог бы перезапускать цикл просмотра очередей сообщений несколько раз в секунду. 
Вот на каждый такой канал и на каждое событие можно привесить [Команда]у-триггер. Она, например, будет убавлять яркость экрана при включении компа - при событии StartUp, то есть, запуске приложения.
А еще есть событие Завершения Оператора - там надо сохранить данные.
Но до сохранения можно тоже выполнить некие [Команда]ы.
И вот этот список [Команда] для каждого события надо бы настраивать через РИ, тоже через [Команда]ы. Ну или через скрипты хотя бы сейчас. 

+++Идея обработки событий
* Это новая идея как более общий взгляд на работу приложения. Это потребует перепроектировать все в более универсальную единообразную концепцию.
* Оператор можно приспособить для автозапуска [Задача] при старте компьютера или по расписанию или по событию.
Для этого надо просто ввести события и присоединять к ним обработчики [Задача]. К каждому событию можно прицепить несколько обработчиков [Задача]. Например, при старте сессии пользователя виндовс запускать и Оператор и  
выставлять яркость дисплея, как у меня сейчас в автозагрузке, и монтировать виртуальный диск. И такие [Задача]и легко добавлять через этот же интерфейс Оператора.
Еще могут быть другие события. Этот механизм может заменить планировщик виндовс.
В сущности, каждый запрос является событием. Можно добавить события обнаружения нового письма в почте, и обрабатывать их таким же механизмом как [Команда]ы пользователя.
* Можно предложить заводить в систему события вставки и извлечения диска: флешки, плеера итд.
* Можно предложить завести в систему события процессов: запуска или завершения процесса с именем и путем к исполняемому файлу.
* Можно предложить завести в систему события окон: появления на экране окна, получение фокуса ввода итд. 
* Можно предложить завести в систему события почты или мессенджера.
* Можно предложить завести в систему события подключения устройств вроде смартфона и фотоаппарата.
* Можно завести в систему события сетевого интерфейса
* Это все требует существенного объема работы по интеграции операционной системы и этой моей оболочки пользователя. Это уже не частное улучшение отдельного аспекта деятельности, а переработка всех процессов работы на компьютере. Это мне не потянуть за пару месяцев. 

+++Виды каналов событий
Каналы событий можно разделить на встроенные и подключаемые.
Встроенные каналы - встроены в сам Оператор, так как связаны с инфраструктурой окна итп.
Подключаемые каналы событий можно подключать к Оператор, реализовав их как dll и загружая через файл настроек при старте Оператора.
todo: какие должны быть каналы и как их реализовать и использовать?
todo: каждый канал событий вынести в отдельную страницу вики.

++++Встроенные каналы событий
Это каналы событий, которые обрабатываются кодом Движка и не выделены в отдельные загружаемые модули-плагины.
Это поскольку они слишком сложные и многофункциональные. А главное - без них Оператор не работоспособен.
todo: определить, какие точно каналы должны быть встроены в Движок Оператора. И потом - как они должны быть устроены.

++++Канал команд управления исполнением процедур
* См КаналУправленияИсполнениемПроцедур
* Это канал событий клавиш, которые позволяют:
    * приостановить выполнение всех команд, включая текущие исполняемые процедуры.
    * возобновить приостановленное исполнение команд
    * отменить исполнение всех текущих исполняемых процедур, а также команд каналов событий.
        
++++Канал ввода консоли Пользователя
Этот канал принимает сообщения-команды от пользователя.
Эти сообщения попадают в МеханизмВыборкиКоманд, который выбирает подходящую [Команда]у для исполнения.
Затем [Команда]а исполняется.
Этот МеханизмВыборкиКоманд характеристичен для канала.
Он уже работает, в первом прототипе, сейчас его надо осмотреть и описать.
* Вход: Строка текста, введенного пользователем. Возможен многострочный текст.

++++Канал вывода консоли Пользователя
* Через этот канал пользователю передаются выводимые на экран ответы Оператора.
* Это выходной канал сообщений для показа текстов пользователю и преобразования в речь.
* Выход: Строка текста, который должен быть показан пользователю. Возможен многострочный текст.
* Реализован через C#-Event.

++++Канал вывода состояния Оператора
* Через этот канал пользователю передается выводимое на экран состояние Оператора.
* Это выходной канал сообщений для показа состояния Оператора. Типично - в строке состояния главного окна Оператора.
* Выход: Строка текста, который должен быть показан пользователю как состояние Оператора. Короткий однострочный текст.
* Реализован через C#-Event.

++++Канал обратных команд окну
* Это канал выхода команд от Оператора к окну приложения. Он позволяет завершать приложение Оператор изнутри механизма исполнения команд, правильным стандартным путем.
* Окно, получив команду из канала, завершает работу Оператор, или же выполняет другие предусмотренные функции.
* Выход: Строка текста как код команды. Короткий однострочный текст.
* Реализован через C#-Event.

++++Выходной канал сообщений Лога.
* Это выходной канал сообщений Лога для показа Лога пользователю и одновременной записи в файл Лога.
* Выход: Объект сообщения лога, добавленного в лог.

++++Канал Загрузка Оператора
* Это не совсем канал - это одиночное событие - слот для команд. Предопределенная команда, вызываемая сразу после инициализации Оператора. Подобен Канал Завершение Оператора.
* Тут выполняются [Команда]ы, исходя из предположения, что Оператор стартует автозапуском вместе с ОС.
* Тут я хотел установить [Команда]у регулировки яркости дисплея на старом ноутбуке.
* И тут можно установить [Команда]ы загрузки плагинов - модулей МодульСобытий Оператора.
* Это для использования Оператора в качестве замены Планировщика задач на Виндовс. Он тоже по подобным рефлексам работает. Но Оператор в качестве такого планировщика лучше - его можно интегрировать в мои проекты и другие мои [Задача]и.
* Вход: Сейчас реализован как вызов функции в конце инициализации главного окна. Хотя это неправильно - должен быть вызван после инициализации главного окна, так как исполняемые процедуры могут потребовать вывода или ввода пользователя. 
    * Для процедур в этом канале надо избегать взаимодействия с пользователем.  

++++Канал Завершение Оператора
* Это не совсем канал - это одиночное событие - слот для команд. Предопределенная команда, вызываемая сразу после инициализации Оператора. Подобен Канал Загрузка Оператора.
* Тут я пока не знаю что поставить. Но наверняка что-то да придумается. 
* Должен быть очень быстрым.
На завершение приложения операционной системой отводится около минуты.
Далее она выводит сообщение пользователю и тот, обычно, командует завершить процесс принудительно.
Поэтому задания, размещенные в этом канале, должны быть короткими.
В сумме не более минуты времени.
* Вход: Сейчас реализован как вызов функции в начале процедуры завершения главного окна. Хотя это неправильно - должен быть вызван перед завершением главного окна, так как исполняемые процедуры могут потребовать вывода или ввода пользователя. 
    * Для процедур в этом канале надо избегать взаимодействия с пользователем.
    
++++Канал Часы
* Это канал для будильников, уведомлений и задач, запускаемых по расписанию.
* Этот канал используется для выдачи уведомлений - напоминаний. 
* В него поступают секундные события от таймера. 
* Таймер размещается в главном окне приложения.
Более частые события этого же таймера используются для обработки сообщений от других каналов событий.
Поэтому канал часов должен быть встроенным в движок Оператора.
* События секундные используются для выбора напоминаний из СписокНапоминанийПланировщика. Если время и другие условия Напоминания подходят, срабатывает [Команда]а, указанная в Напоминании. Это может быть звуковой файл, текстовое сообщение, исполнение некоторой [Команда]ы или все вместе.
Здесь должен существовать СписокНапоминанийПланировщика. Его можно предварительно сортировать по времени срабатывания, чтобы облегчить посекундный просмотр для сравнения времени. Для компактности можно делать выборку на сутки вперед и хранить эту выборку в памяти Оператора.
Этот СписокНапоминанийПланировщика специально для канала часов.
* Вход: событие новой секунды. Аргументов нет - текущую дату можно получить из кода в любом месте.
* Генерирует секундные события для таймаута закрытия файлов в подсистеме Лога. Уже используется: 13.08.2018 08:36.

++++Канал событий дисковых томов
* Это канал событий вставки и извлечения внешних накопителей. Внешних винтов, флешек, оптических дисков. Устройств, которые монтируются как накопители, например, плеер или смартфон.
* можно добавить команду для отключения флешки. Хотя в винХР реализовать это отключение проблематично, в более свежих версиях проще.
* Можно назначить определенную команду как процедуру-обработчик вставки определенной флешки. Это как автозапуск диска, но более гибкий.
* 31.08.2017 12:41 Сделал тест генератора событий подключения новых томов. Для его использования нужно переопределить оконную процедуру главного окна приложения и потом ловить события вставки и извлечения дисков. 
    * Проект: [file:///C:/Work/myVirtualDisk/МоиПроекты/РечевойИнтерфейс/Материалы/DriveInsertionDetector.7z]
    * В таком же духе можно сделать ловлю событий выключения компьютера, завершение сеанса итд. Только это проще будет.
    * Проверено: это работает в окне, свернутом в трей - см. [file:///C:/Work/myVirtualDisk/МоиПроекты/РечевойИнтерфейс/Материалы/CompactWindowTest.zip]
* Вход: События вставки или удаления дисковых томов.
* Все дисковые тома нужно представлять как Сущности, по названиям. Подобно Месту, тип - дисковый том. Название - метка тома, если есть. А если нет - использовать для идентификации ИД номер файловой системы и размер тома. И требовать у пользователя, чтобы он присвоил тому оригинальное название, чтобы использовать его в скриптах, итп.
    * question: Но если пользователь переформатирует флешку, и забудет метку тома, как потом эту метку обратно восстановить? На нее ведь скрипты уже могут быть навешены по старому имени. Хотя, нет имени - нет и флешки. Другая флешка уже получается, а старые скрипты, конечно, надо бы удалить. Только некому их выявить и изменить.
        * Вывод: для каждой флешки надо сразу определить ее роль, придумать название и настроить для нее Оператор.
        * Такая очень семантическая система получается этот Оператор - каждой сущности должно быть дано свое название и применение. 
    * Лучше бы по серийнику флешки или винта, но это в винХР не работает. 

++++Канал событий питания
* Это канал событий питания компьютера.
* Позволяет получать уведомления о завершении работы, слабом заряде батареи, засыпании и пробуждении компьютера.
* todo: выяснить, какие события питания компьютера можно получать на самом деле. И как их можно применять в Операторе.
* См. КаналСобытийПитанияИСеансаПользователя
* Вход: Код события питания и сеанса
    * Низкий заряд батареи ноутбука
    * Завершение ОС
    * Засыпание ОС 

++++Канал событий сеанса пользователя
* Это канал событий сеанса пользователя.
* Позволяет получать уведомления о завершении сеанса пользователя, временном выходе пользователя из сеанса, открытии сеанса пользователя, итп.
* todo: выяснить, какие события сеанса пользователя можно получать на самом деле. И как их можно применять в Операторе.
* todo: выяснить, можно ли объединить события питания и снанса пользователя в один канал.
    * Я уже объединил их в один канал, но не уверен, что это правильно для их использования в Операторе.  
* См. КаналСобытийПитанияИСеансаПользователя

++++Канал горячих клавиш
* Полезен для вызова заранее определенной процедуры Оператора в любой момент. Для произвольного активного окна можно выполнить нужные операции копирования изменения и обратной вставки его содержимого. Ну и другие полезные операции.
* Должен быть встроенным в Оператор, так как использует очередь сообщений главного окна Оператор.
* Создать набор глобальных горячих клавиш: Alt+Win+F1..Alt+Win+F12.
    * Регистрировать сразу весь набор при старте приложения Оператор.
    * Если не получится регистрировать что-то из этого набора, вывести на экран Оператора сообщение о том что указанный хоткей не может быть привязан к Оператору. И в коде тоже выключить хоткей из использования в Операторе на время сеанса.
    * Возможно, хоткей регистрируется новым приложением а оператор запускается позже и в нем уже этот хоткей занят на некий обработчик. Тогда надо об этом предупредить пользователя и предложить переназначить действие на другой хоткей.
        * todo: Сейчас это слишком сложно и малоиспользуемо, но это влияет на разработку структуры Оператора. Это надо учесть.  
* Завести события нажатия хоткеев в собственный канал событий - канал хоткеев.
  В канал передается событие, содержащее строку - название сработавшего хоткея.
* Назначать команды для событий хоткеев так же, как и для других событий - реконфигурируемо, скриптами.
    * Один из хоткеев - Показать окно Оператор. Сейчас предполагается что это Alt+Win+F1.
* Вход: Строка - название горячей клавиши. 

++++Канал событий окон
* Это канал, в который заводятся сообщения о открытии, активации, деактивации, закрытии окон сторонних приложений.
* Он нужен для работы Оператора с другими приложениями. Например, с помощью горячих клавиш Оператора выполнять работы в текущем активном окне.
* События окон слишком многочисленны, чтобы можно было завести их все подряд. Поэтому надо отобратьтолько практически применимые виды событий окон. 
    * todo: Определить типы событий окон для канала событий окон.
* Вход: ? todo: Определить данные события канала события окон.

++++Канал событий процессов
* Это канал, в который заводятся сообщения о открытии, активации, деактивации, закрытии процессов сторонних приложений.
* Он нужен для отслеживания работы сторонних приложений.
    * Например, на время работы видеоплеера автоматически увеличить яркость монитора.  
* Надо отобрать только практически применимые виды событий процессов. 
    * todo: Определить типы событий процессов для канала событий процессов.
* Вход: ? todo: Определить данные события канала события процессов.
    * Сигнал о запуске процесса? 
    * Сигнал о завершении Процесса?
    * Сигнал о простое процесса?
    * Любого в ОС или только выбранного? 

++++Канал событий сетевого подключения
* Это канал, в который заводятся сообщения о открытии, закрытии сетевого подключения. Ethernet, WiFi, итп.
* Он нужен для наблюдения за сетью.
* todo: Определить типы событий сетевого подключения для канала событий сетевого подключения. 
* Вход: ?  todo: Определить данные события канала события сетевого подключения.
    * Сигнал подключения сети? Или сетевого адаптера?
    * Сигнал отключения сети?
    * Сигнал о появлении еще одного сетевого адаптера?
    * Сигнал о исчезновении сетевого адаптера?

++++Канал событий внешних
* Во многих проектах можно запустить приложение при наступлении некоторого события. Например, конца компиляции программы. Или срабатывании сенсора. Или ярлык в Автозагрузка. 
* Надо написать специальное приложение-извещатель. Код-аббревиатура события передается в командной строке при запуске программы. Приложение должно просто отправить Оператору извещение о событии и завершиться. 
* Оператор должен иметь специальный именованный канал для таких сообщений о событиях. 
* Или можно собственно приложение-оператор сделать так, чтобы только первый экземпляр запускался как Оператор, а остальные - как извещатели о событиях.
    * Но это не лучший вариант. Тут можно код события передавать через командную строку приложения. 
* Вход: Строка с кодом сообщения-события. Передается между процессами по именованному каналу. 

+++Подключаемые каналы событий
В новой версии Оператора нужны добавляемые каналы событий.
Добавляемые - значит их можно добавлять программно, без переделки кода механизма.
Им должны быть сопоставлены [Процедура]ы-обработчики событий.
Эти обработчики могут содержать вызовы других [Процедура] как последовательность или как [Алгоритм].
Возможно, эти обработчики должны быть скриптами?

Все каналы событий, которые можно добавлять как плагины, вероятно, строятся по одной схеме.
Источник события - список последовательно исполняемых [Команда] - собственно исполнение [Команда].
Важно следить, чтобы этот список [Команда] исполнялся полностью до следующего такого события, иначе будет много проблем.
Хотя, вероятно, эти каналы событий тоже в итоге можно просто включить в основной код Движка. Но эксперименты проводить лучше отдельно. 



++Материалы
+++Регулярно выполняемые команды
Оператор должен бы иметь возможность регулярно или по расписанию выполнять назначенные команды.
* Например, каждое утро в 8 часов он должен бы запросить данные погоды, разбудить меня и предоставить отчет о состоянии обстановки.
* Например, каждый час он должен запрашивать данные погоды с датчиков и вести статистику погоды для моего последующего использования.

Как заставить Оператор периодически выполнять некоторую команду?
В канале событий часов можно создавать таймеры событий, подобно тому, как они в планировщике создаются.
Каждый такой таймер-задание должен содержать условие запуска и скрипт или адрес скрипта, содержащего команды.

А как быть с засыпанием компьютера с Оператором?
* Будить компьютер по ближайшему таймштампу, а после завершения исполнения - снова засыпать до следующего таймштампа побудки. Нужна очередь побудок, скользящая и непрерывная. Если до следующей побудки менее 5 минут - не засыпать, а просто ждать, пока время наступит.

todo: тут все же нужны примеры таких ситуаций. Без них сложно представить себе и применение и реализацию.

Такое задание можно назначить специальной командой с диалогом.
Весь этот механизм заданий и будильников укладывается в концепцию Планировщика, вроде моего Органайзера.
Поэтому прпвильно будет его в этом качестве и разрабатывать. Просто задания могут быть однократные или повторяющиеся, и при их срабатывании можно исполнять команды, а не просто выводить уведомления на экран.
А так, пусть хоть каждые 5 минут повторяются, круглосуточно. 

+++Система рефлексов
Это реакции на события.
Сам Оператор настраивать реакции не умеет. Это должен делать пользователь. 
КаналСобытий использует СписокКоманд. Такой же, как сейчас используется для отработки [Команда] от пользователя. Тоже с весом - порядком и приоритетом [Команда]. И так далее.
todo: Надо осмотреть существующий код прототипа и описать его структуру и функции. Именно устройство и работу.
[Команда]ы существуют отдельно от этого СписокКомандКанала (переименовать!) Приоритеты [Команда] (вес) работают внутри КаналСобытий, являясь свойством [Команда]ы внутри КаналСобытий, то есть, частью СписокКомандКанала, а не [Команда]ы.(Поле вес из [Команда]ы убрать, так как оно относится к КаналСобытий.)
Пользователю нужен АПИ для управления СписокКомандКанала для каждого КаналСобытий.
Пользователю нужен АПИ для управления самими КаналСобытий.
Надо придумать, как создавать новые КаналСобытий без перекомпиляции кода.(Уже есть идеи, но их надо увязать воедино.) Там нужен C#-код, чтобы ловить аппаратные события.
    * Можно реализовать КаналСобытий как подключаемый Модуль канала событий, и подключать его подобно вызову [Команда]ы, в процессе старта Оператора. Получится вроде плагина. C#-код мог бы запустить свой поток исполнения, чтобы в бесконечном цикле ожидания выполнять извлечение и обработку событий


+++Механизм обработки событий  - набросок предварительный и кривой

Состоит из:
-линейки импульсов событий ЛИС
-линейки флагов состояний ЛФС

1) ЛИС можно свести в один приемник событий, если каждому событию присвоить уникальное имя.
Единственный приемник событий позволит описывать реакцию системы на события через ЛогическиеПравила.
Набор этих условий-правил можно будет прицепить к процедуре и хранить вместе с процедурой в dll или в БД.
- сейчас процедуры команд пользователя сами проверяют условия в своем коде, и если условия не выполняются - эта процедура завершает работу и выдает сигнал о неподходящем условии. Процедуры идут одна за другой, и так сами отбирают, выполняться им или нет. При исполнении команды пользователя, если процедура выполнена успешно, перебор процедур заканчивается. А тут нужно каждую процедуру попытаться исполнить. В этом вся разница.
2)ЛФС - каждое состояние названо уникальным именем. Если получается не bool, а enum, надо развернуть его в bool флаги, прибавив в название имя устройства или канала.
Такой массив (список?) ЛФС позволит проверять состояние Оператора в коде ЛогическогоПравила.
Это получится компактно и понятно. Пока число этих флагов состояний достаточно малое.
А если оно увеличится, то придется придумать другой способ или более строго использовать состояния.

3) общий механизм обработки событий: [rel://files/оператор диарамма4.JPG]

4) Каждое Правило должно иметь Приоритет(0..1), по нему Правила сортируются в списке правил, чтобы можно было переопределять порядок просмотра списка правил.
Список правил можно записывать вручную, текстовым файлом, (Но приоритет Правила позволяет добавлять правила автоматически) как перечисление НазваниеПравила тогда настройка системы правил должна производиться вручную.

?) Поведение Оператора должно же меняться в зависимости от контекста - текущего состояния уже выполняющихся задач.
Например, контекст БекапСистемы не позволяет выполнять большинство процедур событий.
Но я же не могу заранее предусмотреть и описать все возможные комбинации состояний системы, чтобы учитывать их как флаги ЛФС и предусматривать их в логических правилах процедур.
- контекст может иметь свою маску для ЛФС, блокируя некоторые флаги.
- Надо подробнее изучить этот вопрос.



+++Выходные каналы событий успехов комментариев и ошибок
Выходные тексты могут быть разных классов:
* сообщение об ошибке
* Текст для озвучивания
* Сообщение-комментарий, описание контекста вопроса, отладочные сообщения [Алгоритм]ов
* Сообщения для лога
* Сообщение об успешном завершении [Процедура]ы.
* итд
Соответственно, их надо по разному обрабатывать: выводить на основной экран, в лог, в звуковой канал сообщений.
Звуковой канал сообщений нежелательно забивать подсказками, а то пользователя это раздражает.

+++Процедуры и канал событий
В обработчике канала событий нужно использовать Команды - то есть, тексты, которые механизм исполнения команд переводит в Команды и исполняет. Хотя ранее предполагалось, что в этом списке будут Процедуры. Но это неудобно, так как нужно еще задавать Аргументы через текст.

Надо описать, как в таком случае выглядит обработчик событий КаналСобытий. 
Это похоже на простой текстовый список команд, подобно скрипту алгоритма.
От Винды Оператор отличается здесь тем, что все события собраны в едином месте, и их легко просмотреть и изменить из единого интерфейса.
Хотя в Винде есть Планировщик, и он тоже позволяет обрабатывать события, у Оператора интерфейс должен быть лучше и понятнее.

Входные каналы событий:
- Часы (секундные импульсы)
- Ввод пользователя
- Запуск и выключение компьютера, вход пользователя

Выходные каналы:
- Ответы пользователю
- звуковые сигналы

Можно сделать поле-свойство объекта [Процедура]ы, чтобы сопоставить [Процедура]у каналу. И просматривать для события из канала только сопоставленные [Процедура]ы.

Свойство Вес [Процедура]ы работает для [Процедура] внутри канала.

Как настроить вызов [Процедура]ы по времени? Для канала Часы? Как это именовать в свойствах [Процедура]ы?

На канале Часы будут висеть [Процедура]ы календаря, планировщика, будильники итд.


+++Модульная организация Каналов событий - идея
Получится такая надстройка над ОС. Система рефлексов.
Чтобы получить гибкость в добавлении новых КаналСобытий, придется реализовать архитектуру подключаемых модулей МодульСобытий.
МодульСобытий реализован в виде отдельной dll, подобно как для [Процедура].
МодульСобытий подключается подобно [Команда]е в список [Команда], выполняемых при загрузке Оператора. Только тут [Процедура]а не просто завершается, а загружает и присоединяет МодульСобытий, который в дальнейшем используется в Операторе. То есть, она, конечно, завершается. Но выглядит она как [Команда]а в КаналСобытий Загрузка Оператора. И управляется пользователем так же, как и в других КаналСобытий, через интерфейс РИ.

В Операторе есть каркас для этой модульной системы: СписокМодулейСобытий.
СписокМодулейСобытий обрабатывается кодом, запускаемым по таймеру, например, 10 раз в секунду.
Каждый проход такого ЦиклОбработкисообщений просматривает все ОчередьСообщенийСобытий всех МодульСобытий в СписокМодулейСобытий. Исполняет события и в конце цикла засыпает до следующего события, которое начнет новый ЦиклОбработкисообщений.
    * Именно так: После завершения цикла поток спит до следующего события начала цикла. Это можно реализовать флагом или вайт хандле.
    * Если ЦиклОбработкисообщений будет перегружен, то события будут подвисать. Например, Часы.
    * Тут получается много разных одновременных потоков. Это надо проектировать осторожно и внимательно!

Собственно МодульСобытий реализован неким С#-классом, в котором есть функции и интерфейсы для сопряжения с Оператором.
В МодульСобытий может работать собственный поток, отслеживая и обрабатывая события из некоторого источника.
Внутри МодульСобытий Событие превращается в объект СообщениеОСобытии и помещается в ОчередьСообщенийСобытий внутри МодульСобытий. Очередь это разновидность списка. Но она межпоточная, поэтому СообщениеОСобытии должно быть устойчивым между разными потоками.
ОчередьСообщенийСобытий доступна  Оператору через ИнтерфейсМодуляСобытий, через который также можно управлять этим МодульСобытий.
Во время работы МодульСобытий отдает Оператору СообщениеОСобытии, если они есть в ОчередьСообщенийСобытий.

Работы с МодульСобытий: (это все входит в ИнтерфейсМодуляСобытий)
* Процесс Загрузка Оператора:
    * Загрузка модуля.
    * Инициализация модуля
    * Запуск получения событий
* Процесс Работа Оператора:
    * Получение события
* Процесс Завершение Оператора:
    * Останов получения событий
    * Деинициализация модуля
    * Выгрузка модуля.

Модуль загружается как dll, Инициализируется, Запускается генерация событий.
Во время работы модуль отдает Оператору события, если они есть в его ОчередьСообщенийСобытий.
Если модуль нужно остановить, он останавливается и перестает пополнять свою ОчередьСообщенийСобытий.
Это нужно в процессе Завершение Оператора, чтобы очереди сообщений не переполнялись, пока завершаются модули.
Выгрузка dll - это неуправляемый процесс, и происходит вместе с другими dll при завершении процесса Оператора.

При первой Инициализации МодульСобытий должен создать инфраструктуру в БД Оператора. Чтобы в дальнейшем ее использовать.
Вероятно, у МодульСобытий должна быть ВерсияМодуляСобытий, чтобы не возникало несовместимости версий МодульСобытий и Оператор.

Хотя это проектируется как чисто модульная схема, возможно, лучше будет основные модули встроить в код Оператора, а остальные так вот модульно подключать. 
Основные модули - ввод и вывод текста для пользователя, часы, питание, еще что-то.
Дополнительные модули - события сети, дисков, яхз что еще. Вот их можно наращивать потом без переделки движка.
И распространять как дополнения через ПакетЗнаний. 



