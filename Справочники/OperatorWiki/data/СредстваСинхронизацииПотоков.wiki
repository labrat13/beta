++ Средства Синхронизации Потоков

Тут кратко описаны имеющиеся в Net Framework 2.0 средства синхронизации потоков и их доступа к данным.

+++AutoResetEvent
* Это разновидность EventWaitHandle с автоматическим сбросом. Управляемый поток ждет на WaitOne, управляющий - вызывает Set(), это освобождает управляемый поток и семафор сразу же сбрасывается в исходное состояние. Поэтому он пропускает только один поток, даже если их там несколько ждет на семафоре.
* EventWaitHandle можно создать с автоматическим или ручным сбросом. При ручном сбросе после вызова Set() семафор пропускает все потоки, пока его не сбросят (вызовом Reset()?).
* На схеме это можно отобразить как реле с контактом. 
    [rel://files/AutoResetEvent.JPG]

+++Mutex
* Мог бы охранять очередь сообщений или буфер сообщения.
* Создается как объект. Передается потоку как объект, по ссылке.
* пример кода:
private void UseResource()
{
    //mutex как объект был создан ранее в этом классе
    mutex.WaitOne();//поток будет ждать, пока мутекс освободится
    //монопольно выполнить работы с объектом
    mutex.ReleaseMutex(); //поток должен освободить мутекс
    
    return;
}

+++Interlocked
* содержит функции для атомарного изменения данных
* Этим можно передавать между потоками неблокирующие сигналы вроде общих счетчиков и даже проверок и замен значений.
* Этим можно передавать потоку флаг Стоп. например. Хотя и так можно - просто установить значение Int32 - атомарная операция.

+++Монопольный доступ к списку объектов
Для списка сообщений - монопольный доступ к списку на время работы:
* Не проверялось на практике!

ICollection ic = (ICollection) list;
lock(ic.SyncRoot)
{
//тут монопольно выполняем работы с списком
};//end lock

Первый поток получает доступ к списку, остальные спят, ждут, пока освободится список.

+++Работа с контролами формы из других потоков
* Обычно с контролами может работать только поток, обслуживающий окно формы. Все прочие потоки вызывают исключение - что-то про контекст. Хотя, не каждый раз, почему-то.
* Другой поток может вызывать функции контролов формы через Control.Invoke(..).
И там потом надо создать делегат - функцию, которая будет передана потоку, обслуживающему окно формы. Он и будет делать всю работу. А вызывающий поток ждет завершения этого Делегата.
* todo: добавить сюда пример кода, выполняющего такую работу.
* todo: BeginInvoke / EndInvoke описать, что они делают.
* 